# Task ID: 8
# Title: Update Navigation Components
# Status: in-progress
# Dependencies: 4, 5
# Priority: medium
# Description: Refactor the application sidebar to show or hide items based on user permissions.
# Details:
1. Update `AppSidebar.tsx` to use the new permission system
2. Replace any `usePermission` hooks with `useAbility`
3. Wrap navigation items with the `<Authorized>` component
4. Define the required permission for each navigation item
5. Ensure smooth rendering without layout shifts when items are hidden
6. Test with different user roles to verify correct visibility

# Test Strategy:
Create tests that render the sidebar with different user roles and verify that the correct navigation items are shown or hidden. Include snapshot tests to catch unintended changes.

# Subtasks:
## 1. Define Permission Structure and Create Authorized Component [done]
### Dependencies: None
### Description: Set up the foundation for permission-based navigation by defining the permission structure and creating the Authorized component that will wrap navigation items.
### Details:
1. Define a centralized permission structure in a dedicated file (e.g., `permissions.ts`):
   - Create enums or constants for all navigation-related permissions
   - Define role-to-permission mappings for different user roles

2. Create the `<Authorized>` component that will wrap navigation items:
   - Accept `permission` or `permissions` prop to specify required access
   - Use the new `useAbility` hook to check if the current user has the required permission
   - Implement proper TypeScript typing for the component
   - Add support for rendering fallback content when permission is denied

3. Testing approach:
   - Write unit tests for the `<Authorized>` component with different permission scenarios
   - Test with mock user contexts having different permission sets
   - Verify that children are rendered only when permissions are satisfied

<info added on 2025-04-28T10:50:17.929Z>
## Implementation Details for Permission Structure

1. **Permission Schema Design**:
   ```typescript
   // Example implementation for permissions.ts
   export enum Permission {
     VIEW_DASHBOARD = 'view:dashboard',
     MANAGE_USERS = 'manage:users',
     EDIT_SETTINGS = 'edit:settings',
     // Add all navigation-related permissions
   }

   export enum Role {
     ADMIN = 'admin',
     MANAGER = 'manager',
     USER = 'user',
   }

   export const rolePermissions: Record<Role, Permission[]> = {
     [Role.ADMIN]: Object.values(Permission),
     [Role.MANAGER]: [Permission.VIEW_DASHBOARD, Permission.EDIT_SETTINGS],
     [Role.USER]: [Permission.VIEW_DASHBOARD],
   };
   ```

2. **Authorized Component Implementation**:
   ```typescript
   // Example implementation for Authorized.tsx
   import React from 'react';
   import { useAbility } from '../hooks/useAbility';
   import { Permission } from '../policies/permissions';

   interface AuthorizedProps {
     permissions: Permission | Permission[];
     fallback?: React.ReactNode;
     children: React.ReactNode;
   }

   export const Authorized: React.FC<AuthorizedProps> = ({ 
     permissions, 
     fallback = null, 
     children 
   }) => {
     const { can } = useAbility();
     
     const hasPermission = Array.isArray(permissions)
       ? permissions.some(permission => can(permission))
       : can(permissions);
     
     return hasPermission ? <>{children}</> : <>{fallback}</>;
   };
   ```

3. **Unit Testing Strategy**:
   ```typescript
   // Example test for Authorized.tsx
   describe('Authorized', () => {
     it('renders children when user has permission', () => {
       // Mock useAbility to return true for specific permission
       jest.mock('../hooks/useAbility', () => ({
         useAbility: () => ({ can: () => true })
       }));
       
       render(
         <Authorized permissions={Permission.VIEW_DASHBOARD}>
           <div data-testid="protected-content">Protected Content</div>
         </Authorized>
       );
       
       expect(screen.getByTestId('protected-content')).toBeInTheDocument();
     });
     
     it('renders fallback when user lacks permission', () => {
       // Mock useAbility to return false
       jest.mock('../hooks/useAbility', () => ({
         useAbility: () => ({ can: () => false })
       }));
       
       render(
         <Authorized 
           permissions={Permission.MANAGE_USERS}
           fallback={<div data-testid="fallback">Access Denied</div>}
         >
           <div>Protected Content</div>
         </Authorized>
       );
       
       expect(screen.getByTestId('fallback')).toBeInTheDocument();
       expect(screen.queryByText('Protected Content')).not.toBeInTheDocument();
     });
   });
   ```

4. **Performance Considerations**:
   - Implement memoization for permission checks to avoid unnecessary re-renders
   - Consider using React.memo for the Authorized component itself
   - Cache permission results when checking multiple permissions

5. **Migration Path from Legacy Components**:
   - Create a HOC version of Authorized for class components if needed
   - Provide clear examples in documentation for different usage patterns
</info added on 2025-04-28T10:50:17.929Z>

## 2. Refactor AppSidebar Structure for Permission-Based Rendering [done]
### Dependencies: 8.1
### Description: Update the AppSidebar component to support permission-based rendering without causing layout shifts when items are hidden.
### Details:
1. Refactor `AppSidebar.tsx` structure to support permission-based rendering:
   - Analyze the current sidebar structure and identify potential layout shift issues
   - Implement a consistent layout structure that won't shift when items are hidden
   - Consider using CSS Grid or Flexbox with placeholder elements if needed
   - Replace any direct permission checks with the new permission system

2. Create a navigation item configuration that includes permission requirements:
   - Define a data structure for navigation items that includes title, icon, link, and required permission
   - Move hardcoded navigation items into this configuration
   - Ensure the structure is extensible for future navigation changes

3. Testing approach:
   - Create snapshot tests for the sidebar with different permission sets
   - Manually test layout stability by toggling permissions
   - Verify that no layout shifts occur when items are hidden

## 3. Implement Permission-Based Navigation Items [pending]
### Dependencies: 8.1, 8.2
### Description: Apply the Authorized component to each navigation item and replace any existing permission hooks with useAbility.
### Details:
1. Replace all `usePermission` hooks with `useAbility` throughout the navigation components:
   - Update import statements
   - Refactor any permission check logic to use the new hook syntax
   - Ensure proper typing for the new hook usage

2. Wrap each navigation item with the `<Authorized>` component:
   - Use the permission configuration from the previous subtask
   - Apply the `<Authorized>` component to each navigation item
   - Ensure that the component hierarchy remains clean and maintainable

3. Implement proper accessibility for hidden navigation items:
   - Ensure hidden items are not accessible via keyboard navigation
   - Verify that screen readers don't announce hidden items
   - Add appropriate ARIA attributes if needed

4. Testing approach:
   - Test each navigation item with different permission sets
   - Verify that items appear and disappear correctly based on permissions
   - Check accessibility with screen reader and keyboard navigation tests

## 4. Test and Optimize Permission-Based Navigation [pending]
### Dependencies: 8.1, 8.2, 8.3
### Description: Perform comprehensive testing with different user roles and optimize the implementation for performance and user experience.
### Details:
1. Create test scenarios for different user roles:
   - Define test cases for admin, regular user, and other relevant roles
   - Create mock user contexts with different permission sets
   - Test navigation rendering for each role

2. Optimize performance:
   - Memoize permission checks to prevent unnecessary re-renders
   - Use React.memo for navigation items that don't change frequently
   - Implement lazy loading for navigation sections if applicable

3. Enhance user experience:
   - Add subtle animations or transitions when navigation items appear/disappear
   - Ensure the sidebar maintains a consistent visual weight regardless of visible items
   - Consider adding tooltips for navigation items that explain permission requirements

4. Final verification and documentation:
   - Verify that all requirements from the task description are met
   - Document the new permission-based navigation system
   - Create examples for adding new navigation items with permissions
   - Update any relevant developer documentation

5. Testing approach:
   - Perform end-to-end testing with different user roles
   - Measure and document performance metrics
   - Conduct cross-browser testing to ensure consistent behavior

