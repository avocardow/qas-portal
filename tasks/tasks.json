{
  "tasks": [
    {
      "id": 1,
      "title": "Database Schema Migration for Notifications",
      "description": "Implement the database schema changes to enhance the notifications table with new columns and constraints as specified in the PRD.",
      "status": "done",
      "dependencies": [],
      "priority": "high",
      "details": "Execute SQL migrations to add the following to the notifications table: 'type' column (VARCHAR(50) NOT NULL), 'entityId' column (VARCHAR(255)), 'createdByUserId' column (VARCHAR(255) NOT NULL). Add foreign key constraints to users table. Create indexes for performance optimization (idx_notifications_user_unread, idx_notifications_user_created, idx_notifications_type_entity, idx_notifications_created_by). Add enum constraint for notification types to ensure valid values ('client_assignment', 'audit_assignment', 'audit_stage_update', 'audit_status_update'). Test the migration with rollback capability.",
      "testStrategy": "Verify schema changes using database inspection tools. Test foreign key constraints with sample data. Validate indexes with EXPLAIN queries. Ensure constraint enforcement by attempting invalid insertions.",
      "subtasks": [
        {
          "id": 1,
          "title": "Document current schema and create migration plan",
          "description": "Document the existing notifications table schema and create a detailed migration plan with goals, risks, and rollback strategy",
          "status": "done",
          "dependencies": [],
          "details": "Create comprehensive documentation of the current notifications table structure. Define the migration objectives aligned with business goals. Document the planned changes including new columns ('type', 'entityId', 'createdByUserId'), foreign key constraints, and indexes. Identify potential risks and create a detailed rollback strategy. Use version control to track all documentation and migration scripts. Include validation steps to ensure data integrity throughout the migration process."
        },
        {
          "id": 2,
          "title": "Create migration scripts with rollback capability",
          "description": "Develop SQL migration scripts that add the new columns and constraints with proper rollback functionality",
          "status": "done",
          "dependencies": [
            1
          ],
          "details": "Write SQL migration scripts to add the new columns: 'type' (VARCHAR(50) NOT NULL), 'entityId' (VARCHAR(255)), and 'createdByUserId' (VARCHAR(255) NOT NULL) to the notifications table. Create corresponding rollback scripts that can revert these changes. Implement the enum constraint for notification types ('client_assignment', 'audit_assignment', 'audit_stage_update', 'audit_status_update'). Ensure scripts are idempotent and can be safely run multiple times. Store all scripts in version control with clear naming conventions that indicate execution order."
        },
        {
          "id": 3,
          "title": "Implement foreign key constraints and indexes",
          "description": "Add foreign key constraints and create the specified indexes for performance optimization",
          "status": "done",
          "dependencies": [
            2
          ],
          "details": "Create SQL scripts to add foreign key constraints linking the 'createdByUserId' column to the users table. Implement the four required indexes: idx_notifications_user_unread (for filtering unread notifications by user), idx_notifications_user_created (for sorting notifications by creation date), idx_notifications_type_entity (for filtering by notification type and entity), and idx_notifications_created_by (for filtering by creator). Include rollback scripts that drop these constraints and indexes. Test the constraint behavior to ensure it properly enforces referential integrity."
        },
        {
          "id": 4,
          "title": "Set up automated testing environment",
          "description": "Create an isolated testing environment and automated tests to validate the migration",
          "status": "done",
          "dependencies": [
            3
          ],
          "details": "Set up a dedicated testing environment that mirrors the production database. Create automated tests that verify: successful column addition, constraint enforcement, index creation and performance, and rollback functionality. Implement data validation tests to ensure existing data remains intact. Create tests for the enum constraint to verify it properly restricts values. Develop performance tests to confirm the new indexes improve query performance as expected. Document all test cases and expected results."
        },
        {
          "id": 5,
          "title": "Execute migration in staging environment",
          "description": "Deploy the migration to staging, perform validation tests, and verify application compatibility",
          "status": "done",
          "dependencies": [
            4
          ],
          "details": "Execute the migration scripts in the staging environment following the dual-write pattern: first deploy code that can handle both old and new schema, then migrate the schema while maintaining backward compatibility. Verify that the application correctly interacts with the new schema. Run performance tests to ensure the new indexes improve query efficiency. Validate that the enum constraint properly restricts notification types. Test the rollback procedure to confirm it works as expected. Document any issues encountered and their resolutions."
        },
        {
          "id": 6,
          "title": "Deploy to production and monitor",
          "description": "Execute the migration in production with monitoring and post-deployment verification",
          "status": "done",
          "dependencies": [
            5
          ],
          "details": "Schedule the production migration during a low-traffic period. Implement monitoring to track database performance during and after migration. Execute the migration scripts with careful validation at each step. Verify that all new columns, constraints, and indexes are created correctly. Monitor application performance and database query execution times. Have the rollback plan ready for immediate execution if issues arise. After successful deployment, document the completed migration, including any deviations from the original plan. Remove any temporary dual-write code after confirming stability."
        }
      ]
    },
    {
      "id": 2,
      "title": "Create Notification Service",
      "description": "Develop a notification service that handles message templating, notification creation, and implements smart notification logic.",
      "status": "done",
      "dependencies": [
        1
      ],
      "priority": "high",
      "details": "Create src/server/services/notificationService.ts with functions for different notification types: createClientAssignment, createAuditAssignment, and createAuditUpdate. Implement message template generation with React-compatible formatting using the NotificationMessage type structure. Add logic for self-notification prevention (skip if creator = recipient), deduplication (check for identical notifications within time window), entity validation, and rate limiting. Include helper functions for user lookup and message formatting. Implement the message formatting system using React component composition instead of HTML tags.",
      "testStrategy": "Write unit tests for each notification creation function. Test edge cases like self-notifications, duplicate notifications, and rate limiting. Mock database interactions for isolated testing.",
      "subtasks": [
        {
          "id": 1,
          "title": "Create NotificationMessage type structure",
          "description": "Define the core data structure for notification messages that supports React-compatible formatting",
          "status": "done",
          "dependencies": [],
          "details": "Create a TypeScript interface for NotificationMessage that includes fields for message content, formatting options, metadata, and React component composition. The structure should support different notification types (client assignment, audit assignment, audit update) and include properties for sender, recipient, timestamp, priority level, and notification status. Ensure the type structure is extensible for future notification types."
        },
        {
          "id": 2,
          "title": "Implement message templating system",
          "description": "Develop a flexible templating system that generates React-compatible notification content",
          "status": "done",
          "dependencies": [
            1
          ],
          "details": "Create helper functions for message formatting that use React component composition instead of HTML tags. Implement template generators for different notification types that populate the NotificationMessage structure. Include support for dynamic content insertion, conditional formatting based on notification type, and internationalization capabilities. Design the system to be extensible for future template additions."
        },
        {
          "id": 3,
          "title": "Create user lookup and entity validation functions",
          "description": "Implement utility functions for user identification and entity validation",
          "status": "done",
          "dependencies": [
            1
          ],
          "details": "Develop helper functions to look up user information needed for notifications. Create validation functions to verify that entities referenced in notifications (clients, audits, assignments) exist and are valid. Implement error handling for cases where entities cannot be found or are invalid. These functions will be used by the notification creation functions to ensure data integrity."
        },
        {
          "id": 4,
          "title": "Implement core notification creation functions",
          "description": "Create the primary notification generation functions for different notification types",
          "status": "done",
          "dependencies": [
            1,
            2,
            3
          ],
          "details": "Implement the three main notification functions: createClientAssignment, createAuditAssignment, and createAuditUpdate. Each function should accept appropriate parameters, validate inputs, generate the notification message using the templating system, and return a properly formatted NotificationMessage object. Include proper error handling and logging for each function."
        },
        {
          "id": 5,
          "title": "Develop self-notification prevention and deduplication logic",
          "description": "Implement logic to prevent unnecessary notifications",
          "status": "done",
          "dependencies": [
            4
          ],
          "details": "Add logic to skip notification creation when the creator is the same as the recipient (self-notification prevention). Implement deduplication logic that checks for identical notifications within a configurable time window. Create a mechanism to compare notification content and metadata to identify duplicates. This should include a caching strategy or database query approach to efficiently check recent notifications."
        },
        {
          "id": 6,
          "title": "Implement rate limiting functionality",
          "description": "Create a rate limiting system to prevent notification flooding",
          "status": "done",
          "dependencies": [
            4,
            5
          ],
          "details": "Develop a rate limiting mechanism that restricts the number of notifications sent to a user within a specific time period. Implement configurable thresholds for different notification types and priorities. Create a storage solution to track notification counts and timestamps. Add logic to queue or delay notifications that exceed rate limits, ensuring important notifications are still delivered appropriately."
        },
        {
          "id": 7,
          "title": "Integrate and test the complete notification service",
          "description": "Combine all components into a cohesive service and create comprehensive tests",
          "status": "done",
          "dependencies": [
            1,
            2,
            3,
            4,
            5,
            6
          ],
          "details": "Create the main notificationService.ts file that exports all notification functions and utilities. Implement proper error handling, logging, and performance monitoring. Write unit tests for each component of the service, including template generation, notification creation, deduplication, and rate limiting. Create integration tests that verify the complete notification workflow. Document the API and usage patterns for the notification service."
        }
      ]
    },
    {
      "id": 3,
      "title": "Implement tRPC Notification Router",
      "description": "Create a tRPC router for notifications with queries, mutations, and subscription endpoints.",
      "status": "done",
      "dependencies": [
        1,
        2
      ],
      "priority": "high",
      "details": "Create src/server/api/routers/notification.ts with the following endpoints: 'getUnread' query to fetch unread notifications for current user, 'markAsRead' mutation to mark a notification as read, 'markAllAsRead' mutation to mark all notifications as read, 'getCount' query to get unread notification count, and 'subscribe' subscription for real-time notification stream with user filtering. Implement proper authentication and validation. Ensure the subscription endpoint filters notifications by userId for security. Add the notification router to the main tRPC router.",
      "testStrategy": "Test each endpoint with various input scenarios. Verify authentication requirements. Test subscription with multiple concurrent users. Ensure proper error handling for invalid inputs.",
      "subtasks": [
        {
          "id": 1,
          "title": "Create notification router file structure",
          "description": "Set up the basic file structure for the notification router with proper imports and router initialization",
          "status": "done",
          "dependencies": [],
          "details": "Create the file src/server/api/routers/notification.ts. Import the necessary tRPC components (router, procedure) from your tRPC server initialization file. Initialize an empty notification router using the router() function. Export the router for later integration with the main app router. Include any required validation libraries (like zod) and authentication utilities that will be needed for the endpoints."
        },
        {
          "id": 2,
          "title": "Implement query endpoints for notifications",
          "description": "Create the 'getUnread' and 'getCount' query procedures for fetching unread notifications and counts",
          "status": "done",
          "dependencies": [
            1
          ],
          "details": "In the notification router, implement two query procedures: 1) 'getUnread' - Add authentication middleware to ensure only authenticated users can access their notifications. Use input validation to handle pagination/filtering parameters if needed. Implement the resolver function to fetch unread notifications for the current user from your data source. 2) 'getCount' - Similarly secure this endpoint and implement a resolver that returns just the count of unread notifications for the authenticated user. Both queries should properly handle error cases and return typed responses."
        },
        {
          "id": 3,
          "title": "Implement mutation endpoints for notifications",
          "description": "Create the 'markAsRead' and 'markAllAsRead' mutation procedures",
          "status": "done",
          "dependencies": [
            1
          ],
          "details": "Add two mutation procedures to the notification router: 1) 'markAsRead' - Use input validation to ensure a valid notification ID is provided. Add authentication to verify the user owns the notification being marked. Implement the resolver to update the notification status in your data store. 2) 'markAllAsRead' - Add authentication to ensure only the user's own notifications are affected. Implement the resolver to update all unread notifications for the current user. Both mutations should return appropriate success/failure responses and handle error cases properly."
        },
        {
          "id": 4,
          "title": "Implement subscription endpoint for real-time notifications",
          "description": "Create the 'subscribe' subscription procedure with proper user filtering",
          "status": "done",
          "dependencies": [
            1
          ],
          "details": "Implement the 'subscribe' subscription procedure in the notification router. Add authentication to ensure users can only subscribe to their own notifications. Create a subscription resolver that establishes a real-time connection and emits new notifications as they arrive. Implement proper filtering logic to ensure users only receive notifications intended for them (filter by userId). Set up any necessary event emitters or pub/sub mechanisms needed for the subscription to work. Ensure proper cleanup when subscriptions are terminated."
        },
        {
          "id": 5,
          "title": "Add security and validation",
          "description": "Enhance all endpoints with comprehensive input validation and security checks",
          "status": "done",
          "dependencies": [
            2,
            3,
            4
          ],
          "details": "Review all implemented endpoints and add thorough input validation using a schema validation library like Zod. Implement proper error handling for all procedures. Add security checks to ensure users can only access their own notifications. For the subscription endpoint, add additional validation to prevent unauthorized access to notification streams. Implement rate limiting if necessary to prevent abuse. Add logging for security-relevant events. Test all endpoints with various invalid inputs to ensure robust validation."
        },
        {
          "id": 6,
          "title": "Integrate notification router with main tRPC router",
          "description": "Add the notification router to the main application router and test the complete implementation",
          "status": "done",
          "dependencies": [
            5
          ],
          "details": "Import the notification router in your main tRPC router file (typically src/server/api/root.ts or similar). Add the notification router to the main router object using the appropriate key (e.g., 'notification'). Verify that all endpoints are accessible through the main router. Test the complete implementation to ensure all notification endpoints work correctly with proper authentication, validation, and error handling. Verify that the subscription endpoint correctly filters notifications by userId. Document any specific usage patterns or requirements for frontend developers."
        }
      ]
    },
    {
      "id": 4,
      "title": "Enhance NotificationDropdown Component",
      "description": "Update the existing NotificationDropdown component to display notifications with real-time updates.",
      "status": "done",
      "dependencies": [
        3
      ],
      "priority": "medium",
      "details": "Modify src/components/header/NotificationDropdown.tsx to implement real-time tRPC subscription for instant notification updates. Add unread count badge integration. Implement click-to-navigate functionality with read status marking. Add connection status indicator and auto-reconnection handling for dropped connections. Use optimistic updates for read status changes. Uncomment the NotificationDropdown component in AppHeader to re-enable it. Implement the renderMessage function to properly format notification messages with bold text using React components.",
      "testStrategy": "Create component tests with mock subscription data. Test UI rendering for different notification states (read/unread). Verify badge count updates. Test navigation on notification click. Simulate connection drops to verify reconnection logic.",
      "subtasks": [
        {
          "id": 1,
          "title": "Implement Real-Time tRPC Subscription for Notifications",
          "description": "Integrate a real-time tRPC subscription in NotificationDropdown to receive instant notification updates and manage notification state accordingly.",
          "status": "done",
          "dependencies": [],
          "details": "Set up a tRPC subscription hook within NotificationDropdown.tsx to listen for new notifications and updates. Ensure the component state is updated in real time as new notifications arrive or existing ones change. Handle initial loading and error states. This subtask lays the foundation for all subsequent real-time features."
        },
        {
          "id": 2,
          "title": "Add Unread Count Badge and Optimistic Read Status Updates",
          "description": "Display an unread notifications badge and implement optimistic UI updates when marking notifications as read.",
          "status": "done",
          "dependencies": [
            1
          ],
          "details": "Calculate the unread notification count from the state and display it as a badge on the dropdown trigger. When a notification is marked as read (e.g., on click), optimistically update its status in the UI before awaiting server confirmation. Roll back the change if the server update fails."
        },
        {
          "id": 3,
          "title": "Implement Click-to-Navigate and Read Status Marking",
          "description": "Enable navigation to a relevant page when a notification is clicked and mark it as read.",
          "status": "done",
          "dependencies": [
            2
          ],
          "details": "Attach click handlers to each notification item. On click, navigate to the notification's target (using React Router or similar), and trigger the optimistic read status update. Ensure accessibility and keyboard navigation are supported."
        },
        {
          "id": 4,
          "title": "Add Connection Status Indicator and Auto-Reconnection Handling",
          "description": "Display a connection status indicator for the real-time subscription and handle automatic reconnection if the connection drops.",
          "status": "done",
          "dependencies": [
            1
          ],
          "details": "Monitor the tRPC subscription connection state. Show a visual indicator (e.g., colored dot or icon) reflecting connection status (connected, reconnecting, disconnected). Implement logic to automatically attempt reconnection and update the indicator accordingly."
        },
        {
          "id": 5,
          "title": "Enhance Notification Message Rendering and Re-enable Dropdown",
          "description": "Implement the renderMessage function to format notification messages with bold text using React components, and uncomment NotificationDropdown in AppHeader.",
          "status": "done",
          "dependencies": [
            3,
            4
          ],
          "details": "Write the renderMessage function to parse and render notification messages, applying bold formatting where appropriate using React elements. Ensure messages are visually clear and accessible. Finally, uncomment and re-integrate NotificationDropdown in AppHeader to make the enhanced component available in the UI."
        }
      ]
    },
    {
      "id": 5,
      "title": "Integrate Client Assignment Notifications",
      "description": "Add notification triggers for client assignment changes in client creation and update flows.",
      "status": "done",
      "dependencies": [
        2,
        3
      ],
      "priority": "medium",
      "details": "Modify api.clients.update and api.clients.create mutations to trigger notifications when assignedUserId changes. In EditClientModal.tsx and AddClientModal.tsx, add logic to detect assignment changes and call notificationService.createClientAssignment with appropriate parameters (assignedUserId, clientId, clientName, createdByUserId). Ensure self-notification prevention by comparing assignedUserId with session.user.id. Add error handling to prevent notification failures from affecting the main operation.",
      "testStrategy": "Test client creation and updates with different assignment scenarios. Verify notifications are created with correct data. Confirm self-assignments don't create notifications. Test error handling by simulating notification service failures.",
      "subtasks": [
        {
          "id": 1,
          "title": "Implement notificationService.createClientAssignment method",
          "description": "Create the notification service method that will handle client assignment notifications with proper parameters and error handling",
          "status": "done",
          "dependencies": [],
          "details": "Develop the notificationService.createClientAssignment method that accepts assignedUserId, clientId, clientName, and createdByUserId parameters. This method should create and send a notification when a client is assigned to a user. Implement error handling within this method to catch and log any issues without throwing exceptions that would affect the main client operations. The method should return a success/failure status that can be safely ignored by calling code. Include logic to prevent self-notifications by comparing the assignedUserId with the user creating the assignment."
        },
        {
          "id": 2,
          "title": "Modify api.clients.create mutation to trigger notifications",
          "description": "Update the client creation API to detect and trigger notifications for initial client assignments",
          "status": "done",
          "dependencies": [
            1
          ],
          "details": "Modify the api.clients.create mutation to capture the assignedUserId value during client creation. After successfully creating the client record, call the notificationService.createClientAssignment method with the appropriate parameters (assignedUserId, the newly created clientId, clientName, and the session.user.id as createdByUserId). Wrap the notification call in a try/catch block to ensure that any notification failures don't affect the client creation process. Add a comparison check between assignedUserId and session.user.id to prevent self-notifications when users create clients assigned to themselves."
        },
        {
          "id": 3,
          "title": "Update AddClientModal.tsx with notification logic",
          "description": "Enhance the client creation modal to support the notification flow when assigning clients",
          "status": "done",
          "dependencies": [
            1,
            2
          ],
          "details": "Modify the AddClientModal.tsx component to work with the updated api.clients.create mutation. Ensure the component correctly passes the assignedUserId parameter when creating a new client. If the API doesn't automatically trigger notifications, add client-side logic to detect when a client is being created with an assignedUserId and call notificationService.createClientAssignment directly. Implement proper error handling to prevent notification failures from affecting the client creation UI flow. Update any form validation or submission logic as needed to support the new notification requirements."
        },
        {
          "id": 4,
          "title": "Implement notification triggers in api.clients.update and EditClientModal.tsx",
          "description": "Add logic to detect assignment changes during client updates and trigger appropriate notifications",
          "status": "done",
          "dependencies": [
            1
          ],
          "details": "Modify the api.clients.update mutation to detect changes in assignedUserId by comparing the new value with the previous value stored in the database. Only trigger notifications when the assignedUserId actually changes. In the EditClientModal.tsx component, implement logic to track the original assignedUserId when the modal opens and compare it with the new value on submission. If changed, call notificationService.createClientAssignment with the new assignedUserId, clientId, clientName, and session.user.id. Add proper error handling in both the API and UI components to ensure notification failures don't disrupt the main client update functionality. Include the self-notification prevention check by comparing the new assignedUserId with session.user.id."
        }
      ]
    },
    {
      "id": 6,
      "title": "Integrate Audit Assignment Notifications",
      "description": "Add notification triggers for audit assignment changes in audit workflows.",
      "status": "done",
      "dependencies": [
        2,
        3
      ],
      "priority": "medium",
      "details": "Modify api.audit.assignUser mutation to trigger notifications when users are assigned to audits. In EditAuditModal.tsx and AddAuditModal.tsx, add logic to detect assignment changes and call notificationService.createAuditAssignment with appropriate parameters (assignedUserId, auditId, clientName, auditYear, createdByUserId). Ensure self-notification prevention by comparing assignedUserId with session.user.id. Add error handling to prevent notification failures from affecting the main operation.",
      "testStrategy": "Test audit assignment with different scenarios. Verify notifications are created with correct data. Confirm self-assignments don't create notifications. Test error handling by simulating notification service failures.",
      "subtasks": [
        {
          "id": 1,
          "title": "Update api.audit.assignUser Mutation to Trigger Notifications",
          "description": "Modify the backend mutation responsible for assigning users to audits so that it triggers a notification event when an assignment occurs.",
          "status": "done",
          "dependencies": [],
          "details": "In the api.audit.assignUser mutation, add logic to call notificationService.createAuditAssignment with the required parameters (assignedUserId, auditId, clientName, auditYear, createdByUserId) whenever a user is assigned to an audit. Ensure the notification trigger is only called on assignment events and not on unrelated updates."
        },
        {
          "id": 2,
          "title": "Implement Assignment Change Detection in EditAuditModal.tsx and AddAuditModal.tsx",
          "description": "Add logic to the audit modals to detect when the assigned user changes and prepare the necessary data for notification.",
          "status": "done",
          "dependencies": [
            1
          ],
          "details": "In EditAuditModal.tsx and AddAuditModal.tsx, compare the previous and new assignedUserId values to detect assignment changes. When a change is detected, gather auditId, clientName, auditYear, assignedUserId, and createdByUserId for the notification service call."
        },
        {
          "id": 3,
          "title": "Integrate Self-Notification Prevention Logic",
          "description": "Ensure that notifications are not sent to the user who is performing the assignment action (self-notification prevention).",
          "status": "done",
          "dependencies": [
            2
          ],
          "details": "Before calling notificationService.createAuditAssignment, compare assignedUserId with session.user.id. Only trigger the notification if they are different, thereby preventing users from receiving notifications about their own actions."
        },
        {
          "id": 4,
          "title": "Add Robust Error Handling for Notification Failures",
          "description": "Implement error handling to ensure that failures in the notification process do not affect the main audit assignment operation.",
          "status": "done",
          "dependencies": [
            3
          ],
          "details": "Wrap the notification service call in a try-catch block or use a promise-based error handler. Log any errors or report them to an error monitoring service, but ensure that the audit assignment proceeds regardless of notification success or failure."
        }
      ]
    },
    {
      "id": 7,
      "title": "Implement Audit Progress Update Notifications",
      "description": "Add notification triggers for audit stage and status changes to notify client managers.",
      "status": "done",
      "dependencies": [
        2,
        3
      ],
      "priority": "medium",
      "details": "Modify api.audit.updateAudit mutation to trigger notifications when audit stage or status changes. In EditAuditModal.tsx, add logic to detect stage/status changes and call notificationService.createAuditUpdate with appropriate parameters (clientManagerId from clients.assignedUserId, auditId, clientName, auditYear, changeType, newValue, createdByUserId). Determine if the change is stage or status based on comparison with previous values. Ensure client managers don't receive notifications for their own changes by comparing clientManagerId with session.user.id. Add error handling to prevent notification failures from affecting the main operation.",
      "testStrategy": "Test audit updates with different stage/status changes. Verify notifications are sent to correct client managers. Confirm managers don't receive notifications for their own changes. Test error handling by simulating notification service failures.",
      "subtasks": [
        {
          "id": 1,
          "title": "Enhance Audit Update Mutation to Capture Previous and New Values",
          "description": "Modify the api.audit.updateAudit mutation to capture both previous and new values for audit stage and status, enabling accurate change detection.",
          "status": "done",
          "dependencies": [],
          "details": "Update the mutation logic to fetch and retain the previous values of audit stage and status before applying updates. Ensure these values are available for downstream logic to compare and identify changes."
        },
        {
          "id": 2,
          "title": "Implement Change Detection Logic in EditAuditModal.tsx",
          "description": "Add logic in EditAuditModal.tsx to compare previous and new audit stage/status values, determining if a change has occurred and its type (stage or status).",
          "status": "done",
          "dependencies": [
            1
          ],
          "details": "Within the modal's save/update handler, compare the previous and new values for both stage and status. Set a changeType variable ('stage' or 'status') and newValue accordingly if a change is detected. Ensure this logic is robust to prevent false positives or missed changes."
        },
        {
          "id": 3,
          "title": "Integrate Notification Triggering with Notification Service",
          "description": "Invoke notificationService.createAuditUpdate with the correct parameters when a stage or status change is detected, passing clientManagerId, auditId, clientName, auditYear, changeType, newValue, and createdByUserId.",
          "status": "done",
          "dependencies": [
            2
          ],
          "details": "After detecting a change, call the notification service with all required parameters. Retrieve clientManagerId from clients.assignedUserId and ensure all contextual information (auditId, clientName, auditYear, etc.) is included in the notification payload."
        },
        {
          "id": 4,
          "title": "Implement Self-Notification Prevention Logic",
          "description": "Ensure client managers do not receive notifications for their own changes by comparing clientManagerId with session.user.id before sending notifications.",
          "status": "done",
          "dependencies": [
            3
          ],
          "details": "Before triggering the notification, check if clientManagerId matches the current session user's ID. If they match, skip sending the notification. This prevents redundant or unnecessary notifications to the acting user."
        },
        {
          "id": 5,
          "title": "Add Robust Error Handling for Notification Failures",
          "description": "Implement error handling to ensure notification failures do not affect the main audit update operation, logging errors for later review.",
          "status": "done",
          "dependencies": [
            4
          ],
          "details": "Wrap the notification trigger in a try-catch block. Log any errors encountered during notification sending, but allow the main audit update process to complete successfully regardless of notification outcome."
        }
      ]
    },
    {
      "id": 8,
      "title": "Implement Browser Push Notifications",
      "description": "Add browser notification support for users not actively viewing the application.",
      "status": "done",
      "dependencies": [
        4
      ],
      "priority": "low",
      "details": "Create a browser notification service that handles permission requests and notification creation. Implement context-aware permission request that triggers only when the first notification is about to be sent. Create structured browser notifications with title, body, icon, and action buttons as specified in the PRD. Implement click handling for browser notifications to navigate to the appropriate page. Add permission state management and graceful fallback to in-app only if permissions are denied. Use the Notification API with the specified BrowserNotification interface structure. Handle notification click events to open the appropriate page and mark as read.",
      "testStrategy": "Test permission request flow with different browser settings. Verify notification display with various message types. Test click handling and navigation. Verify graceful fallback when permissions are denied. Test across different browsers for compatibility.",
      "subtasks": [
        {
          "id": 1,
          "title": "Design Browser Notification Interface and Service",
          "description": "Define the BrowserNotification interface structure and create a notification service module to encapsulate all browser notification logic.",
          "status": "done",
          "dependencies": [],
          "details": "Specify the BrowserNotification interface with fields for title, body, icon, and action buttons as per the PRD. Implement a notification service class or module that exposes methods for requesting permission, creating notifications, and handling notification events. Ensure the service is modular and reusable."
        },
        {
          "id": 2,
          "title": "Implement Permission Request and State Management",
          "description": "Handle browser notification permission requests and manage the user's permission state within the application.",
          "status": "done",
          "dependencies": [
            1
          ],
          "details": "Add logic to request notification permissions only when the first notification is about to be sent (context-aware). Store and track the permission state (granted, denied, default) in the service. Ensure that permission requests are not shown unnecessarily and that the UI reflects the current permission state."
        },
        {
          "id": 3,
          "title": "Create Structured Notification Generation Logic",
          "description": "Implement the logic to generate and display browser notifications using the Notification API, following the structured format defined in the interface.",
          "status": "done",
          "dependencies": [
            2
          ],
          "details": "Use the Notification API to create notifications with the specified title, body, icon, and action buttons. Ensure the notification payload is validated and structured according to the interface. Integrate with the service worker if required for background notifications[3]."
        },
        {
          "id": 4,
          "title": "Implement Notification Click Handling and Navigation",
          "description": "Handle click events on browser notifications to navigate users to the appropriate page and mark notifications as read.",
          "status": "done",
          "dependencies": [
            3
          ],
          "details": "Add event listeners for notification click events, either in the main app or in the service worker for background notifications[3]. Implement logic to open the relevant page (using window focus or navigation) and update the notification state to 'read' in the application."
        },
        {
          "id": 5,
          "title": "Add Graceful Fallback to In-App Notifications",
          "description": "Implement fallback logic to display in-app notifications if browser notification permissions are denied or unavailable.",
          "status": "done",
          "dependencies": [
            2
          ],
          "details": "Check the permission state before attempting to send a browser notification. If permissions are denied or unsupported, trigger the existing in-app notification system instead, ensuring users are always notified regardless of browser capabilities."
        },
        {
          "id": 6,
          "title": "Test and Validate Notification Flows Across Browsers",
          "description": "Thoroughly test browser notification flows, permission handling, click actions, and fallback mechanisms on all supported browsers and platforms.",
          "status": "done",
          "dependencies": [
            4,
            5
          ],
          "details": "Verify that notifications are displayed correctly with all specified fields, permission requests are context-aware, click actions work as intended, and fallback to in-app notifications occurs when necessary. Address any browser-specific quirks or limitations discovered during testing."
        }
      ]
    },
    {
      "id": 9,
      "title": "Implement Multi-device Read Status Synchronization",
      "description": "Ensure notification read status is synchronized across multiple devices for the same user.",
      "status": "done",
      "dependencies": [
        3,
        4
      ],
      "priority": "low",
      "details": "Enhance the markAsRead and markAllAsRead mutations to broadcast read status changes to all connected clients. Update the frontend subscription handler to process read status updates from other sessions. Implement optimistic UI updates for read status changes to improve perceived performance. Add logic to handle conflicts when multiple devices attempt to mark the same notification as read. Ensure the unread count badge updates in real-time across all devices when a notification is read on any device.",
      "testStrategy": "Test with multiple browser sessions for the same user. Verify read status synchronizes across sessions. Test conflict resolution with simultaneous read operations. Measure performance impact of synchronization.",
      "subtasks": [
        {
          "id": 1,
          "title": "Enhance Backend Mutations to Broadcast Read Status Changes",
          "description": "Modify the markAsRead and markAllAsRead backend mutations to broadcast notification read status updates to all active sessions/devices for the user.",
          "status": "done",
          "dependencies": [],
          "details": "Update the backend logic so that when a notification is marked as read (individually or in bulk), a real-time event (e.g., via WebSocket, GraphQL subscription, or push notification) is emitted to all connected clients for the user. Ensure the event payload includes notification IDs and the new read status. This lays the foundation for cross-device synchronization[1][2][4]."
        },
        {
          "id": 2,
          "title": "Update Frontend Subscription Handler for Real-Time Read Status",
          "description": "Implement or update the frontend logic to listen for read status updates from the backend and update the UI accordingly.",
          "status": "done",
          "dependencies": [
            1
          ],
          "details": "On the frontend, subscribe to the backend's real-time read status events. When an event is received, update the notification list and unread count badge to reflect the new read status. Ensure the UI updates seamlessly, even if the change originated from another device[2][4]."
        },
        {
          "id": 3,
          "title": "Implement Optimistic UI Updates for Read Actions",
          "description": "Provide immediate UI feedback when a user marks a notification as read, before receiving backend confirmation.",
          "status": "done",
          "dependencies": [
            2
          ],
          "details": "When the user marks a notification as read, immediately update the UI to reflect the change (optimistic update). If the backend later reports a failure or conflict, revert the UI change and notify the user as appropriate. This improves perceived performance and responsiveness."
        },
        {
          "id": 4,
          "title": "Add Conflict Resolution Logic for Simultaneous Read Actions",
          "description": "Handle cases where multiple devices attempt to mark the same notification as read at the same time, ensuring consistency.",
          "status": "done",
          "dependencies": [
            1
          ],
          "details": "Implement backend logic to detect and resolve conflicts when concurrent read actions occur. Use event identifiers or timestamps to determine the correct state, ensuring all devices converge on the same read status[1]. Optionally, notify clients of any conflict resolution outcomes."
        },
        {
          "id": 5,
          "title": "Synchronize and Update Unread Count Badge in Real-Time",
          "description": "Ensure the unread count badge updates instantly across all devices when a notification is read on any device.",
          "status": "done",
          "dependencies": [
            2,
            4
          ],
          "details": "Tie the unread count badge to the real-time subscription handler so it updates immediately upon receiving read status events. Test across multiple devices to confirm that the badge remains accurate and consistent, regardless of where the action originated."
        }
      ]
    },
    {
      "id": 10,
      "title": "Performance Optimization and Testing",
      "description": "Optimize notification system performance and conduct comprehensive testing.",
      "status": "done",
      "dependencies": [
        4,
        5,
        6,
        7,
        8,
        9
      ],
      "priority": "low",
      "details": "Implement pagination for large notification lists to improve loading performance. Add connection pooling for WebSocket connections to reduce server load. Implement exponential backoff for reconnection attempts. Add monitoring for notification service performance. Optimize database queries with proper indexing. Conduct load testing with high notification volumes. Implement accessibility improvements including screen reader announcements for new notifications. Add responsive design adjustments for mobile notification viewing. Create comprehensive test suite covering all notification scenarios.",
      "testStrategy": "Conduct performance testing with simulated high loads. Measure response times and resource usage. Test with screen readers for accessibility compliance. Verify mobile responsiveness on different devices. Run integration tests covering the full notification lifecycle. Test error recovery scenarios and connection reliability.",
      "subtasks": [
        {
          "id": 1,
          "title": "Implement Pagination for Notification Lists",
          "description": "Create an efficient pagination system for notification lists to improve frontend performance and reduce server load when handling large volumes of notifications.",
          "dependencies": [],
          "details": "Implementation steps:\n1. Add cursor-based pagination to notification API endpoints using limit and cursor parameters\n2. Implement database query optimization with LIMIT and OFFSET clauses\n3. Create indexed queries to support efficient pagination\n4. Add infinite scroll functionality in the frontend using IntersectionObserver API\n5. Implement skeleton loading states for paginated content\n6. Cache paginated results using Redis with appropriate TTL\n7. Add proper HTTP headers for cache control\n\nTesting approach:\n- Unit test pagination logic with various page sizes\n- Measure and compare load times before and after implementation\n- Test with large datasets (10,000+ notifications)\n- Verify memory usage remains stable during scrolling",
          "status": "done",
          "parentTaskId": 10
        },
        {
          "id": 2,
          "title": "Implement WebSocket Connection Pooling",
          "description": "Set up connection pooling for WebSockets to efficiently manage connections, reduce server resource consumption, and improve scalability for the notification system.",
          "dependencies": [],
          "details": "Implementation steps:\n1. Configure a connection pool manager using a library like ws or Socket.IO\n2. Implement connection reuse patterns to avoid creating new connections unnecessarily\n3. Set appropriate pool size limits based on expected concurrent users\n4. Add connection timeout and idle connection cleanup mechanisms\n5. Implement health checks for connections in the pool\n6. Add metrics collection for connection pool usage\n7. Configure graceful shutdown procedures for the connection pool\n\nTesting approach:\n- Measure connection establishment time before and after pooling\n- Test with simulated concurrent connections (1000+)\n- Monitor server resource usage under load\n- Verify connections are properly recycled and not leaking",
          "status": "done",
          "parentTaskId": 10
        },
        {
          "id": 3,
          "title": "Implement Exponential Backoff for Reconnection",
          "description": "Create a robust reconnection strategy with exponential backoff to handle network interruptions gracefully and prevent overwhelming the server with reconnection attempts.",
          "dependencies": [
            2
          ],
          "details": "Implementation steps:\n1. Design a backoff algorithm with configurable initial delay, maximum delay, and jitter\n2. Implement client-side reconnection logic that increases wait time between attempts\n3. Add randomized jitter to prevent thundering herd problems\n4. Create a connection state machine (disconnected, connecting, connected)\n5. Implement event handlers for connection failures and successful reconnections\n6. Add user feedback during reconnection attempts\n7. Set maximum retry limits and fallback to polling if needed\n\nTesting approach:\n- Simulate network interruptions to verify reconnection behavior\n- Test with various network conditions (high latency, packet loss)\n- Verify backoff intervals increase correctly\n- Ensure the system recovers and synchronizes state after reconnection",
          "status": "done",
          "parentTaskId": 10
        },
        {
          "id": 4,
          "title": "Set Up Monitoring for Notification Service",
          "description": "Implement comprehensive monitoring and alerting for the notification system to track performance metrics, identify bottlenecks, and ensure reliable operation.",
          "dependencies": [
            2,
            3
          ],
          "details": "Implementation steps:\n1. Integrate Prometheus for metrics collection with custom metrics for notification delivery rates, queue lengths, and latency\n2. Set up Grafana dashboards for visualization of key performance indicators\n3. Implement distributed tracing using OpenTelemetry to track notification flow across services\n4. Configure alerting thresholds for critical metrics (queue backlog, error rates, latency spikes)\n5. Add logging with structured format and appropriate log levels\n6. Implement health check endpoints for service status monitoring\n7. Create a notification delivery status tracking system\n\nTesting approach:\n- Verify metrics are correctly collected under various load conditions\n- Test alert triggering with simulated failure scenarios\n- Validate dashboard accuracy with known workloads\n- Ensure tracing captures the complete notification lifecycle",
          "status": "done",
          "parentTaskId": 10
        },
        {
          "id": 5,
          "title": "Optimize Database Queries with Proper Indexing",
          "description": "Analyze and optimize database queries related to notifications, implementing appropriate indexes to improve query performance and reduce database load.",
          "dependencies": [
            1
          ],
          "details": "Implementation steps:\n1. Analyze query patterns using database profiling tools to identify slow queries\n2. Create compound indexes for frequently used query patterns (user_id + created_at, status + priority)\n3. Implement database query caching using Redis for frequently accessed notification data\n4. Optimize JOIN operations and consider denormalization where appropriate\n5. Implement database connection pooling to manage concurrent connections efficiently\n6. Add query timeout handling to prevent long-running queries\n7. Consider partitioning strategies for the notifications table if volume is very high\n\nTesting approach:\n- Benchmark query performance before and after optimization\n- Use EXPLAIN ANALYZE to verify index usage\n- Test with production-scale data volumes\n- Monitor database load during peak notification periods",
          "status": "done",
          "parentTaskId": 10
        },
        {
          "id": 6,
          "title": "Conduct Load Testing and Implement UI Improvements",
          "description": "Perform comprehensive load testing of the notification system and implement accessibility and responsive design improvements for better user experience across devices.",
          "dependencies": [
            1,
            2,
            3,
            5
          ],
          "details": "Implementation steps:\n1. Set up load testing environment using k6 or JMeter to simulate high notification volumes\n2. Create test scenarios for various load patterns (steady, spike, gradual increase)\n3. Implement accessibility improvements including ARIA attributes for notification elements\n4. Add screen reader announcements for new notifications using aria-live regions\n5. Enhance responsive design with specific breakpoints for mobile notification viewing\n6. Optimize notification rendering for touch interfaces\n7. Implement performance budgets for notification UI components\n\nTesting approach:\n- Run load tests with gradually increasing concurrent users (up to 10,000)\n- Measure system behavior under sustained high load\n- Test accessibility with screen readers and automated tools (Axe, Lighthouse)\n- Verify responsive design across various device sizes and orientations",
          "status": "done",
          "parentTaskId": 10
        },
        {
          "id": 7,
          "title": "Create Comprehensive Test Suite for Notification Scenarios",
          "description": "Develop a complete test suite covering all notification scenarios, including unit tests, integration tests, and end-to-end tests to ensure system reliability.",
          "dependencies": [
            1,
            2,
            3,
            4,
            5,
            6
          ],
          "details": "Implementation steps:\n1. Create unit tests for core notification logic (formatting, prioritization, routing)\n2. Implement integration tests for notification delivery across different channels\n3. Develop end-to-end tests for complete notification workflows\n4. Set up test fixtures and factories for generating test notification data\n5. Implement property-based testing for edge cases and boundary conditions\n6. Create visual regression tests for notification UI components\n7. Set up continuous integration pipeline to run tests automatically\n\nTesting approach:\n- Aim for high test coverage (>80%) for critical notification components\n- Include tests for error handling and edge cases\n- Test notification delivery across all supported channels\n- Verify correct behavior for various notification types and priorities\n- Test notification preferences and user-specific settings",
          "status": "done",
          "parentTaskId": 10
        }
      ]
    }
  ],
  "metadata": {
    "projectName": "QAS Portal Notifications System",
    "totalTasks": 10,
    "sourceFile": "PRD_notifications-v1.txt",
    "generatedAt": "2023-11-09"
  }
}