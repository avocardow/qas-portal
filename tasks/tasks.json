{
  "tasks": [
    {
      "id": 1,
      "title": "Setup Client Profile Page Structure",
      "description": "Create the basic page structure for the client profile at the specified path with routing and layout components.",
      "status": "pending",
      "dependencies": [],
      "priority": "high",
      "details": "Create the page file at `src/app/(pages)/(dashboard)/(app)/clients/[clientId]/page.tsx`. Set up the TailAdmin grid layout using `xl:grid-cols-12` for responsive design. Include `PageBreadcrumb` component at the top. Implement the basic page structure with placeholder sections for all the required components (KPI cards, tables, charts, etc.). Follow Cursor rules for code styling and component usage.",
      "testStrategy": "Verify page renders without errors. Test responsive breakpoints to ensure layout collapses properly on mobile. Check that routing with dynamic [clientId] parameter works correctly.",
      "subtasks": [
        {
          "id": 1,
          "title": "Create basic client profile page file with routing",
          "description": "Set up the initial page file at the specified path with proper Next.js routing configuration",
          "status": "pending",
          "dependencies": [],
          "details": "Create the file at `src/app/(pages)/(dashboard)/(app)/clients/[clientId]/page.tsx`. Implement the basic React component structure with proper TypeScript typing for the dynamic route parameter. Set up the page component to receive and validate the clientId parameter from the URL. Include proper export default statement and implement basic error handling for invalid client IDs."
        },
        {
          "id": 2,
          "title": "Implement responsive TailAdmin grid layout",
          "description": "Set up the responsive grid layout structure using TailAdmin components",
          "status": "pending",
          "dependencies": [
            1
          ],
          "details": "Implement the TailAdmin grid layout using `xl:grid-cols-12` for responsive design. Create the main container div with appropriate TailAdmin classes. Set up responsive breakpoints for different screen sizes (sm, md, lg, xl). Ensure the layout follows the Cursor code styling rules. Add appropriate padding, margins, and gap settings for the grid layout."
        },
        {
          "id": 3,
          "title": "Add PageBreadcrumb component",
          "description": "Integrate the PageBreadcrumb component at the top of the page",
          "status": "pending",
          "dependencies": [
            2
          ],
          "details": "Import the `PageBreadcrumb` component from the shared components library. Configure the breadcrumb with the correct navigation path (Dashboard > Clients > Client Profile). Ensure the client name is dynamically displayed in the breadcrumb when available. Style the breadcrumb according to the design system with proper spacing above and below the component."
        },
        {
          "id": 4,
          "title": "Create placeholder sections for KPI cards",
          "description": "Set up the structure for KPI cards section with appropriate grid positioning",
          "status": "pending",
          "dependencies": [
            2
          ],
          "details": "Create a section for KPI cards with appropriate grid column spans. Implement placeholder components for each KPI card with loading states. Position the KPI cards in the top section of the page. Use TailAdmin card components with proper styling. Include placeholder titles, values, and icons for each KPI card."
        },
        {
          "id": 5,
          "title": "Implement placeholder sections for tables",
          "description": "Create the structure for data tables with proper grid positioning",
          "status": "pending",
          "dependencies": [
            2
          ],
          "details": "Set up placeholder table components in the appropriate grid positions. Create table headers with placeholder column names. Implement skeleton loading states for table rows. Add pagination controls as placeholders. Ensure tables are responsive and maintain proper styling on different screen sizes. Follow TailAdmin table component guidelines."
        },
        {
          "id": 6,
          "title": "Add placeholder sections for charts",
          "description": "Create the structure for chart components with proper grid positioning",
          "status": "pending",
          "dependencies": [
            2
          ],
          "details": "Implement placeholder chart components in the designated grid areas. Set up chart containers with appropriate dimensions and responsive behavior. Add placeholder titles and legends for each chart. Create skeleton loading states for charts. Ensure chart containers follow the design system's styling guidelines."
        },
        {
          "id": 7,
          "title": "Integrate layout components and finalize page structure",
          "description": "Connect all placeholder sections and ensure proper layout integration",
          "status": "pending",
          "dependencies": [
            3,
            4,
            5,
            6
          ],
          "details": "Connect all previously created sections into a cohesive page layout. Ensure proper spacing between all components. Implement any necessary wrapper components for consistent styling. Add appropriate error boundaries around each section. Test the responsive behavior across all breakpoints. Verify that the layout follows the Cursor rules for code styling and component usage. Add comments for future implementation of actual data fetching and component functionality."
        }
      ]
    },
    {
      "id": 2,
      "title": "Implement Client Data Fetching",
      "description": "Set up tRPC call to fetch all client data with related entities using Prisma relations.",
      "status": "pending",
      "dependencies": [
        1
      ],
      "priority": "high",
      "details": "Implement the tRPC call `api.clients.getById({ clientId })` with all required Prisma relations: contacts â†’ licenses, trustAccounts, audits, activityLogs, documentReferences, and assignedUser (client manager). Use Next.js App Router data fetching patterns as referenced in Context7. Implement error handling and loading states. Initially load all client and related entity fields to allow for refinement later.",
      "testStrategy": "Test API call with various client IDs. Verify all related entities are properly loaded. Check error handling for non-existent clients or server errors.",
      "subtasks": [
        {
          "id": 1,
          "title": "Create tRPC router for client queries",
          "description": "Set up the basic tRPC router structure for client-related queries",
          "status": "pending",
          "dependencies": [],
          "details": "Create a new router file (e.g., 'app/server/routers/clients.ts') that will contain all client-related procedures. Initialize the router with the publicProcedure from your tRPC setup. This will serve as the foundation for implementing the getById procedure. Make sure to export the router properly so it can be merged with your main router."
        },
        {
          "id": 2,
          "title": "Define Prisma query with all required relations",
          "description": "Implement the Prisma query that fetches a client by ID with all required relations",
          "status": "pending",
          "dependencies": [
            1
          ],
          "details": "In the clients router, create a helper function that constructs the Prisma query to fetch a client by ID. Include all required relations in the include object: contacts, licenses, trustAccounts, audits, activityLogs, documentReferences, and assignedUser. Initially fetch all fields for each relation to allow for refinement later. Structure the query to handle potential null values and optimize for performance."
        },
        {
          "id": 3,
          "title": "Implement the getById tRPC procedure",
          "description": "Create the tRPC procedure that accepts a clientId parameter and returns the client data",
          "status": "pending",
          "dependencies": [
            1,
            2
          ],
          "details": "Implement the getById procedure using tRPC's query method. Use zod to validate the input parameter (clientId). Call the Prisma query function created in the previous subtask. Implement proper error handling for cases like invalid IDs or database errors. Return the full client object with all relations. The procedure should be defined as: publicProcedure.input(z.object({ clientId: z.string() })).query(async ({ input }) => { /* implementation */ })."
        },
        {
          "id": 4,
          "title": "Connect tRPC router to Next.js App Router",
          "description": "Ensure the clients router is properly connected to the main tRPC router and exposed via the API route",
          "status": "pending",
          "dependencies": [
            3
          ],
          "details": "Import the clients router in your main router file and merge it with other routers. Ensure the API route handler at 'app/api/trpc/[trpc]/route.ts' is properly set up to handle the new client queries. Test the endpoint by navigating to the appropriate URL (e.g., http://localhost:3000/api/trpc/clients.getById) with the required parameters to verify it's working correctly."
        },
        {
          "id": 5,
          "title": "Create client data fetching hooks",
          "description": "Implement React hooks for fetching client data using the tRPC client",
          "status": "pending",
          "dependencies": [
            4
          ],
          "details": "Create a custom hook (e.g., useClientData) that uses the tRPC client to call the getById procedure. Implement loading states, error handling, and data caching strategies. The hook should accept a clientId parameter and return an object with isLoading, isError, error, and data properties. Utilize Next.js App Router data fetching patterns as appropriate, considering both client and server components."
        },
        {
          "id": 6,
          "title": "Implement UI components with loading and error states",
          "description": "Create UI components that use the client data hooks and handle loading and error states",
          "status": "pending",
          "dependencies": [
            5
          ],
          "details": "Develop UI components that consume the client data hook. Implement loading indicators for when data is being fetched. Create error handling components that display appropriate messages when errors occur. Design the components to efficiently display all the related entity data (contacts, licenses, etc.) in a user-friendly manner. Consider implementing progressive loading or virtualization for large datasets."
        }
      ]
    },
    {
      "id": 3,
      "title": "Develop KPI Cards and Charts",
      "description": "Create the financial KPI cards and charts at the top of the profile page.",
      "status": "pending",
      "dependencies": [
        2
      ],
      "priority": "high",
      "details": "Implement the following KPI components using TailAdmin's ComponentCard and chart components: 1) Lifetime Fees Card with sparkline trend, 2) YoY Growth Chart using TailAdmin's chart component, 3) Customer Health Score with colored ribbon, 4) Client Manager Card showing assigned team member. Use the useAbility hook to gate sensitive financial data (estAnnFees) to Admin users only. Include billing commentary from activityLog entries for Admins.",
      "testStrategy": "Verify charts render correctly with sample data. Test permission gating for sensitive fields. Check responsive design of cards at different breakpoints.",
      "subtasks": [
        {
          "id": 1,
          "title": "Create Base KPI Card Components with Data Access Control",
          "description": "Implement the foundational KPI card components with proper data access control using the useAbility hook to gate sensitive financial information for Admin users only.",
          "dependencies": [],
          "details": "1. Create a reusable KPICard component that extends TailAdmin's ComponentCard with the following features:\n   - Configurable title, value, and optional unit display\n   - Support for sparkline/trend visualization\n   - Color-coded indicators for positive/negative values\n   - Responsive design for all screen sizes\n\n2. Implement the useAbility hook integration to gate sensitive financial data:\n   - Create a withFinancialDataAccess HOC or custom hook that checks user permissions\n   - Apply conditional rendering for estAnnFees and other sensitive data\n   - Implement fallback UI for non-admin users (e.g., 'Restricted' message or simplified view)\n\n3. Build the specific KPI card implementations:\n   - Lifetime Fees Card with sparkline trend visualization\n   - Customer Health Score card with colored ribbon indicator\n   - Client Manager Card showing assigned team member\n\n4. Set up unit tests for the components:\n   - Test rendering with and without admin permissions\n   - Test conditional display of sensitive data\n   - Test responsive behavior\n\nUse TailAdmin's existing component structure for consistency while ensuring the cards follow best practices for KPI visualization with clear, uncluttered presentation of metrics.",
          "status": "pending",
          "parentTaskId": 3
        },
        {
          "id": 2,
          "title": "Implement YoY Growth Chart Component",
          "description": "Create the Year-over-Year Growth chart component using TailAdmin's chart components with appropriate visualizations for financial trend data.",
          "dependencies": [
            1
          ],
          "details": "1. Analyze TailAdmin's chart component capabilities and select the appropriate chart type for YoY growth visualization:\n   - Bar chart for month-by-month comparison\n   - Line chart for continuous trend visualization\n   - Consider dual-axis chart if comparing multiple metrics\n\n2. Implement the YoY Growth Chart component:\n   - Create a wrapper around TailAdmin's chart component\n   - Configure appropriate axes, legends, and tooltips\n   - Implement responsive sizing based on container width\n   - Add interactive elements (hover states, tooltips with detailed data)\n\n3. Add data transformation utilities:\n   - Create functions to format raw financial data for chart consumption\n   - Implement percentage calculation for YoY comparisons\n   - Add support for different time period comparisons (YoY, QoQ, MoM)\n\n4. Implement performance optimizations:\n   - Use React.memo to prevent unnecessary re-renders\n   - Implement data memoization for expensive calculations\n   - Consider lazy loading for the chart component\n\n5. Write tests for the chart component:\n   - Test rendering with various data scenarios\n   - Test responsiveness and resize behavior\n   - Test data transformation functions\n\nEnsure the chart follows financial data visualization best practices with clear labeling, appropriate color schemes for financial data, and tooltips that provide context for the displayed metrics.",
          "status": "pending",
          "parentTaskId": 3
        },
        {
          "id": 3,
          "title": "Integrate Billing Commentary and Finalize KPI Dashboard Layout",
          "description": "Integrate billing commentary from activityLog entries for Admin users and finalize the layout of all KPI components at the top of the profile page.",
          "dependencies": [
            1,
            2
          ],
          "details": "1. Implement the billing commentary feature for Admin users:\n   - Create a BillingCommentary component that filters activityLog entries related to billing\n   - Apply the useAbility hook to ensure only Admin users can view this component\n   - Design an expandable/collapsible interface for detailed commentary\n   - Implement sorting by date with most recent comments first\n\n2. Create a responsive grid layout for the KPI dashboard:\n   - Arrange KPI cards in a responsive grid at the top of the profile page\n   - Position the YoY Growth Chart prominently\n   - Ensure proper spacing and alignment between components\n   - Implement breakpoints for different screen sizes (desktop, tablet, mobile)\n\n3. Add final integration and state management:\n   - Connect all components to their respective data sources\n   - Implement loading states and error handling\n   - Add refresh functionality for real-time data updates\n   - Ensure consistent styling across all KPI components\n\n4. Implement comprehensive testing:\n   - Create integration tests for the complete KPI dashboard\n   - Test the dashboard with different user roles and permissions\n   - Verify responsive behavior across different viewport sizes\n   - Test data refresh and error handling scenarios\n\nFinalize the implementation by ensuring all components maintain visual consistency with TailAdmin's design system, follow accessibility best practices (WCAG compliance), and provide a cohesive user experience that highlights the most important financial KPIs at a glance.",
          "status": "pending",
          "parentTaskId": 3
        }
      ]
    },
    {
      "id": 4,
      "title": "Build Audit Progress and Schedule Components",
      "description": "Create the audit cycle progress bar and upcoming audit schedule components.",
      "status": "pending",
      "dependencies": [
        2
      ],
      "priority": "high",
      "details": "Implement the Audit Cycle Progress Bar using TailAdmin's progress-bar component, showing progress from last audit's reportDueDate to next due date. Create the Upcoming Audit Schedule card resembling CRM UpcomingSchedule, listing next audit milestones. Use Intl.DateTimeFormat for date formatting as referenced in Context7.",
      "testStrategy": "Test progress calculation logic with various date ranges. Verify schedule displays correctly with different audit statuses. Check date formatting across browsers.",
      "subtasks": [
        {
          "id": 1,
          "title": "Set up TailAdmin progress bar component structure",
          "description": "Create the base structure for the Audit Cycle Progress Bar component using TailAdmin's progress-bar component",
          "status": "pending",
          "dependencies": [],
          "details": "Create a new React component file for the Audit Cycle Progress Bar. Import the necessary TailAdmin progress bar component from the component library. Set up the component's basic structure with props for current progress percentage, last audit date, and next audit due date. The progress bar should be responsive and follow the TailAdmin styling guidelines with appropriate background colors and rounded corners."
        },
        {
          "id": 2,
          "title": "Implement progress calculation logic",
          "description": "Create utility functions to calculate progress percentage between last audit's reportDueDate and next due date",
          "status": "pending",
          "dependencies": [
            1
          ],
          "details": "Develop a utility function that takes the last audit's reportDueDate and the next audit due date as inputs and calculates the current progress as a percentage. The calculation should handle edge cases such as when the dates are invalid or when the current date is outside the expected range. Implement proper date handling using JavaScript's Date object. The function should return a value between 0-100 representing the percentage completion of the audit cycle."
        },
        {
          "id": 3,
          "title": "Add date formatting with Intl.DateTimeFormat",
          "description": "Implement date formatting utilities using Intl.DateTimeFormat for consistent date display",
          "status": "pending",
          "dependencies": [
            2
          ],
          "details": "Create a utility function that uses Intl.DateTimeFormat to format dates consistently throughout the components. Configure the formatter with appropriate locale and formatting options (day, month, year, etc.). Ensure the function handles different date formats and edge cases gracefully. This utility will be used for displaying dates in both the progress bar and upcoming schedule components."
        },
        {
          "id": 4,
          "title": "Complete Audit Cycle Progress Bar component",
          "description": "Finalize the progress bar component with labels, tooltips, and responsive design",
          "status": "pending",
          "dependencies": [
            1,
            2,
            3
          ],
          "details": "Enhance the progress bar component with labels showing the last audit date and next due date using the date formatting utility. Add tooltips to display additional information when users hover over different parts of the progress bar. Implement responsive design to ensure the component displays correctly on different screen sizes. Add appropriate accessibility attributes (aria-* tags) and ensure the component meets accessibility standards."
        },
        {
          "id": 5,
          "title": "Create Upcoming Audit Schedule card structure",
          "description": "Set up the base structure for the Upcoming Audit Schedule component based on CRM UpcomingSchedule",
          "status": "pending",
          "dependencies": [
            3
          ],
          "details": "Create a new React component for the Upcoming Audit Schedule card, following the design pattern of the CRM UpcomingSchedule component. Set up the card container with appropriate styling, header, and content areas. Implement the component to accept an array of upcoming audit milestones as props. Use TailAdmin card components and styling guidelines to maintain consistency with the rest of the dashboard."
        },
        {
          "id": 6,
          "title": "Implement milestone listing functionality",
          "description": "Develop the functionality to list and display upcoming audit milestones in chronological order",
          "status": "pending",
          "dependencies": [
            5
          ],
          "details": "Implement the logic to sort and display upcoming audit milestones in chronological order. Each milestone should display the event name, date (formatted using the date formatting utility), and any additional relevant information. Add visual indicators for different types of milestones (e.g., planning meetings, fieldwork, report deadlines). Implement conditional styling to highlight imminent milestones or those requiring attention."
        },
        {
          "id": 7,
          "title": "Integrate components with data sources and test",
          "description": "Connect the components to data sources and perform comprehensive testing",
          "status": "pending",
          "dependencies": [
            4,
            6
          ],
          "details": "Integrate both components with the appropriate data sources to fetch audit dates and milestones. Implement data fetching logic with proper error handling and loading states. Test the components with various data scenarios including edge cases (no data, past due dates, etc.). Verify that the progress calculation works correctly across different audit cycle timeframes. Ensure both components render correctly and maintain performance when integrated into the larger application."
        }
      ]
    },
    {
      "id": 5,
      "title": "Implement Contacts Table and Network Diagram",
      "description": "Create the contacts table and relationship network diagram.",
      "status": "pending",
      "dependencies": [
        2
      ],
      "priority": "medium",
      "details": "Build the Recent Contacts Table using TailAdmin's DataTableTwo component with columns for Name (linked to /contacts/[id]), Email, Phone, Title, and Primary badge. Display multiple licenses per contact cleanly. Implement the Contact Network Diagram showing relationships between client, contacts, and trust accounts. Reference DataTableTwo APIDocs from Context7 for implementation details.",
      "testStrategy": "Test table sorting and filtering. Verify links to contact profiles work correctly. Test network diagram with various relationship configurations.",
      "subtasks": [
        {
          "id": 1,
          "title": "Set up DataTableTwo component structure",
          "description": "Initialize and configure the DataTableTwo component from TailAdmin for the Recent Contacts Table implementation",
          "status": "pending",
          "dependencies": [],
          "details": "Create a new component file for the Contacts Table. Import the DataTableTwo component from TailAdmin. Set up the basic table structure with appropriate props and configuration options. Define the table container with responsive styling using Tailwind CSS classes. Reference the TailAdmin documentation for proper component initialization and configuration options."
        },
        {
          "id": 2,
          "title": "Define contact data schema and column configuration",
          "description": "Create the data schema and column configuration for the Contacts Table with all required fields",
          "status": "pending",
          "dependencies": [
            1
          ],
          "details": "Define the data schema for contacts with fields for Name, Email, Phone, Title, and Primary badge status. Configure columns with appropriate headers, cell renderers, and sorting options. Implement the Name column with links to individual contact pages using the '/contacts/[id]' route pattern. Set up proper data types and validation for each field. Create sample data for testing the table implementation."
        },
        {
          "id": 3,
          "title": "Implement multiple licenses display functionality",
          "description": "Create a component to cleanly display multiple licenses per contact within the table",
          "status": "pending",
          "dependencies": [
            2
          ],
          "details": "Design and implement a custom cell renderer component for displaying multiple licenses. Use Tailwind CSS for styling license badges or tags with appropriate colors and spacing. Implement collapsible/expandable functionality if the number of licenses exceeds a certain threshold. Ensure the display is responsive and maintains table layout integrity. Test with contacts having varying numbers of licenses."
        },
        {
          "id": 4,
          "title": "Create data fetching and state management logic",
          "description": "Implement the data fetching and state management for the Contacts Table",
          "status": "pending",
          "dependencies": [
            2
          ],
          "details": "Set up data fetching logic using React hooks or a state management library. Implement pagination, sorting, and filtering functionality. Create loading and error states for the table. Implement search functionality for the contacts table. Set up proper state updates when data changes. Ensure the table maintains its state during user interactions."
        },
        {
          "id": 5,
          "title": "Design the Contact Network Diagram component",
          "description": "Create the basic structure and layout for the Contact Network Diagram",
          "status": "pending",
          "dependencies": [],
          "details": "Research and select an appropriate visualization library for network diagrams (e.g., D3.js, React Flow, or Vis.js). Create a new component for the Contact Network Diagram. Design the basic layout and container for the diagram. Implement responsive behavior for different screen sizes. Set up the component with proper props and configuration options."
        },
        {
          "id": 6,
          "title": "Implement relationship data model and visualization",
          "description": "Create the data model and visualization for relationships between clients, contacts, and trust accounts",
          "status": "pending",
          "dependencies": [
            5
          ],
          "details": "Define the data structure for representing relationships between entities (clients, contacts, trust accounts). Implement node rendering for different entity types with distinct visual representations. Create edge rendering for relationships with appropriate styling. Implement interactive features like zooming, panning, and node selection. Add tooltips or information panels to display additional details about entities and relationships."
        },
        {
          "id": 7,
          "title": "Integrate and finalize both components",
          "description": "Integrate the Contacts Table and Network Diagram components into the main application and finalize implementation",
          "status": "pending",
          "dependencies": [
            4,
            6
          ],
          "details": "Integrate both components into the main application layout. Implement any necessary interactions between the table and diagram (e.g., selecting a contact in the table highlights it in the diagram). Add final styling and UI polish using Tailwind CSS. Perform comprehensive testing across different browsers and screen sizes. Optimize performance for large datasets. Add documentation for component usage and maintenance. Ensure accessibility compliance for both components."
        }
      ]
    },
    {
      "id": 6,
      "title": "Develop Trust Accounts Table and Software Links",
      "description": "Create the trust accounts table with software integration links.",
      "status": "pending",
      "dependencies": [
        2
      ],
      "priority": "medium",
      "details": "Implement the Trust Accounts Table using DataTableTwo with columns for Account Name, Bank Name, BSB, Account Number, Software Access badge, last reconciliation date, managementSoftware, and softwareUrl. Add 'Open in Xero' or 'Open in SharePoint' action buttons in each trust account row, linking to the account's management software or external feed.",
      "testStrategy": "Test table with various trust account configurations. Verify external links open correctly. Test responsive behavior of the table on different screen sizes.",
      "subtasks": [
        {
          "id": 1,
          "title": "Create DataTableTwo schema for Trust Accounts",
          "description": "Define the data structure for the Trust Accounts table with all required columns and data types",
          "status": "pending",
          "dependencies": [],
          "details": "Implement the DataTableTwo schema with the following columns: Account Name (string), Bank Name (string), BSB (string), Account Number (string), Software Access badge (boolean), Last Reconciliation Date (date), Management Software (string), and Software URL (string). Define appropriate data types, validation rules, and default values for each column. Ensure the schema supports filtering and sorting operations that will be needed for the table view."
        },
        {
          "id": 2,
          "title": "Implement data fetching and storage logic",
          "description": "Create the backend services to fetch, store, and update trust account data",
          "status": "pending",
          "dependencies": [
            1
          ],
          "details": "Develop the data service that will handle CRUD operations for trust accounts. Implement methods to fetch trust account data from the database, create new accounts, update existing accounts, and delete accounts when needed. Include error handling and validation logic. If using SharePoint as a data source, implement the SharePoint REST API calls to interact with the SharePoint lists that store trust account data. Ensure proper authentication and authorization checks are in place."
        },
        {
          "id": 3,
          "title": "Build Trust Accounts Table UI component",
          "description": "Create the DataTableTwo component to display trust accounts with all required columns",
          "status": "pending",
          "dependencies": [
            1,
            2
          ],
          "details": "Implement the UI component using DataTableTwo to display trust accounts. Configure the table with all columns defined in the schema. Implement sorting, filtering, and pagination features. Style the table according to design specifications, including the Software Access badge visual indicator. Ensure the table is responsive and accessible. Add empty state handling and loading indicators for better user experience."
        },
        {
          "id": 4,
          "title": "Implement software integration links logic",
          "description": "Create the logic to generate and validate external software links",
          "status": "pending",
          "dependencies": [
            2
          ],
          "details": "Develop the service to generate valid links to external software systems (Xero, SharePoint) based on the managementSoftware and softwareUrl fields. Implement URL validation and security checks. Create helper functions to format URLs with proper parameters and authentication tokens if needed. For SharePoint links, use the SharePoint high-trust configuration to ensure secure access. For Xero, implement the appropriate API authentication flow. Include error handling for cases where links cannot be generated."
        },
        {
          "id": 5,
          "title": "Add action buttons with software links",
          "description": "Implement 'Open in Xero' and 'Open in SharePoint' action buttons in each table row",
          "status": "pending",
          "dependencies": [
            3,
            4
          ],
          "details": "Extend the DataTableTwo component to include action buttons in each row. Implement conditional rendering to show 'Open in Xero' or 'Open in SharePoint' buttons based on the managementSoftware field. Connect the buttons to the software integration links logic to generate the correct URLs. Add click handlers that open the links in a new tab/window. Implement visual feedback for button interactions (hover, active states). Ensure buttons are only enabled for users with appropriate permissions."
        },
        {
          "id": 6,
          "title": "Implement last reconciliation date tracking",
          "description": "Add functionality to track and update the last reconciliation date for trust accounts",
          "status": "pending",
          "dependencies": [
            2,
            3
          ],
          "details": "Implement the logic to track when trust accounts were last reconciled. Create a mechanism to update the last reconciliation date field when reconciliation actions are performed. Add visual indicators in the table to highlight accounts that haven't been reconciled recently (e.g., color coding or warning icons for accounts past a certain threshold). Include sorting capability to allow users to sort by reconciliation date. Add filtering options to show only accounts that need reconciliation."
        }
      ]
    },
    {
      "id": 7,
      "title": "Create Activity Card and Tabbed Activity Log",
      "description": "Implement the activity tracking components with filtering and quick-add functionality.",
      "status": "pending",
      "dependencies": [
        2
      ],
      "priority": "medium",
      "details": "Build the Activity Card using TailAdmin's ActivitiesCard to show recent notes, call logs, and status changes with icons. Implement pagination to show only the most recent items. Create the Tabbed Activity Log using headlessui-tabs (referenced in Context7) to group activities by type (Notes, Emails, Calls, Status Changes). Add Filter & Search functionality with full-text filtering and date-range picker. Implement Quick-Add Activity inline controls for adding new activity logs.",
      "testStrategy": "Test pagination controls and verify correct items are displayed. Test tab switching between activity types. Verify search and filtering work as expected. Test adding new activities of different types.",
      "subtasks": [
        {
          "id": 1,
          "title": "Implement Activity Card Base Component",
          "description": "Create the foundational Activity Card component that will display recent activities with appropriate styling and layout",
          "status": "pending",
          "dependencies": [],
          "details": "Create a new component file ActivityCard.tsx using TailAdmin's ActivitiesCard as reference. Implement the card container with proper Tailwind CSS styling including rounded corners, appropriate padding, and responsive design. Set up the basic structure to display activity items with icons, timestamps, and descriptions. Use subtle text styling with proper contrast between primary content (activity description) and secondary content (timestamps, categories) as seen in the reference designs. Ensure the component accepts props for activity data and pagination controls."
        },
        {
          "id": 2,
          "title": "Implement Activity Item Components with Icons",
          "description": "Create the individual activity item components with appropriate icons for different activity types",
          "status": "pending",
          "dependencies": [
            1
          ],
          "details": "Create ActivityItem.tsx component that renders different activity types (notes, calls, emails, status changes) with appropriate icons. Implement conditional rendering based on activity type. Use subtle styling differences to distinguish between activity types while maintaining design consistency. Each activity item should display: icon matching the activity type, timestamp formatted appropriately, activity description with proper text truncation if needed, and any relevant metadata. Ensure proper spacing between items and consistent vertical rhythm."
        },
        {
          "id": 3,
          "title": "Implement Tabbed Interface for Activity Log",
          "description": "Create a tabbed interface using headlessui-tabs to categorize activities by type",
          "status": "pending",
          "dependencies": [
            2
          ],
          "details": "Implement TabbedActivityLog.tsx component using headlessui-tabs library. Create tabs for different activity categories: 'All', 'Notes', 'Emails', 'Calls', and 'Status Changes'. Style the tabs with appropriate Tailwind classes for active/inactive states. Implement tab panels that filter and display the appropriate ActivityItem components based on the selected tab. Ensure smooth transitions between tabs and proper accessibility attributes. Connect the tabbed interface to the activity data source and implement conditional rendering logic to filter activities by type."
        },
        {
          "id": 4,
          "title": "Implement Filtering and Search Functionality",
          "description": "Add filtering capabilities including text search and date range selection",
          "status": "pending",
          "dependencies": [
            3
          ],
          "details": "Create a FilterControls.tsx component with text search input and date range picker. Implement the search functionality with debounced input to filter activities by text content. Add a date range picker component that allows filtering activities within a specific time period. Style the filter controls to match the overall dashboard design with subtle input fields and clear visual feedback. Implement the filter logic that combines both text search and date range criteria. Connect the filter controls to the activity display components to update the visible activities based on filter criteria."
        },
        {
          "id": 5,
          "title": "Implement Quick-Add Activity Functionality",
          "description": "Create inline controls for quickly adding new activity entries of different types",
          "status": "pending",
          "dependencies": [
            3,
            4
          ],
          "details": "Implement QuickAddActivity.tsx component with inline form controls for adding new activities. Create a dropdown or segmented control to select activity type (Note, Email, Call, Status Change). Implement type-specific input fields that appear based on the selected activity type. Add validation for required fields based on activity type. Style the quick-add controls to be compact yet usable, following the dashboard's design language. Implement the submission logic to add new activities to the data source. Add success/error feedback for form submission and reset form after successful submission."
        }
      ]
    },
    {
      "id": 8,
      "title": "Implement SharePoint Integration and Invoices Card",
      "description": "Create the SharePoint folder browser and recent invoices components.",
      "status": "pending",
      "dependencies": [
        2
      ],
      "priority": "medium",
      "details": "Embed the file-manager tree for client's SharePoint folders by reusing AllFolders component. Implement the Recent Invoices Card listing the last 5 invoice documents with status (paid/unpaid) and links to PDFs. Integrate with existing File-Manager components as specified in the PRD.",
      "testStrategy": "Test SharePoint folder navigation. Verify invoice links work correctly. Test with various document states and permissions.",
      "subtasks": [
        {
          "id": 1,
          "title": "Implement SharePoint Folder Browser Component",
          "description": "Create a reusable SharePoint folder browser by adapting the existing AllFolders component to display client's SharePoint folders in a hierarchical tree structure with proper navigation.",
          "dependencies": [],
          "details": "Implementation steps:\n\n1. Set up SharePoint API integration:\n   - Implement authentication using OAuth 2.0 with Azure AD\n   - Configure the @pnp/sp library for SharePoint REST API calls\n   - Create service methods for fetching folder structure and contents\n\n2. Adapt the AllFolders component:\n   - Modify the component to accept SharePoint folder paths\n   - Implement lazy loading to fetch folder contents on demand\n   - Add breadcrumb navigation for easy traversal between folders\n   - Ensure clear visual distinction between files and folders\n\n3. Implement folder navigation:\n   - Create click handlers for folder expansion/collapse\n   - Maintain navigation state using React hooks or context\n   - Add loading indicators during API calls\n   - Implement error handling for permission issues or network failures\n\n4. Testing approach:\n   - Unit test the SharePoint service methods with mock data\n   - Test folder navigation with different folder depths\n   - Verify proper handling of empty folders and error states\n   - Test performance with large folder structures",
          "status": "pending",
          "parentTaskId": 8
        },
        {
          "id": 2,
          "title": "Develop Recent Invoices Card Component",
          "description": "Create a card component that displays the 5 most recent invoice documents with their payment status (paid/unpaid) and direct links to the PDF files.",
          "dependencies": [
            1
          ],
          "details": "Implementation steps:\n\n1. Design the invoices card UI:\n   - Create a responsive card layout using Fluent UI components\n   - Design status indicators for paid/unpaid invoices\n   - Include invoice number, date, amount, and status fields\n   - Add PDF preview or direct download links\n\n2. Implement data fetching:\n   - Create a service to fetch invoice metadata from SharePoint\n   - Implement sorting by date (most recent first)\n   - Add filtering for invoice document types\n   - Limit results to 5 items with option to view more\n\n3. Develop status indicators:\n   - Implement logic to determine payment status from metadata\n   - Create visual indicators (icons/colors) for paid vs. unpaid status\n   - Add tooltips for additional status information\n\n4. Add PDF linking functionality:\n   - Generate secure links to invoice PDFs in SharePoint\n   - Implement preview functionality if applicable\n   - Handle permission checks before displaying links\n\n5. Testing approach:\n   - Unit test the invoice fetching service\n   - Test sorting and filtering logic\n   - Verify correct status determination\n   - Test PDF link generation and security",
          "status": "pending",
          "parentTaskId": 8
        },
        {
          "id": 3,
          "title": "Integrate Components with Existing File-Manager",
          "description": "Connect the SharePoint folder browser and Recent Invoices card with the existing File-Manager components as specified in the PRD, ensuring seamless interaction between components.",
          "dependencies": [
            1,
            2
          ],
          "details": "Implementation steps:\n\n1. Review existing File-Manager architecture:\n   - Analyze current component structure and data flow\n   - Identify integration points for new components\n   - Document required modifications to existing components\n\n2. Implement component integration:\n   - Add the SharePoint folder browser to the main file navigation\n   - Position the Recent Invoices card according to PRD specifications\n   - Ensure consistent styling across all components\n   - Implement shared state management if needed\n\n3. Establish cross-component communication:\n   - Create event handlers for file/folder selection\n   - Implement navigation synchronization between components\n   - Ensure invoice selection in the card updates the main view\n   - Add context awareness between components\n\n4. Optimize performance:\n   - Implement caching for frequently accessed folders\n   - Add pagination or virtualization for large folder structures\n   - Optimize re-renders using React.memo or shouldComponentUpdate\n   - Ensure responsive behavior across device sizes\n\n5. Testing approach:\n   - Integration tests for component interaction\n   - End-to-end tests for common user flows\n   - Verify behavior matches PRD specifications\n   - Test performance with realistic data volumes\n   - Cross-browser and cross-device testing",
          "status": "pending",
          "parentTaskId": 8
        }
      ]
    },
    {
      "id": 9,
      "title": "Build Compliance Components",
      "description": "Create the regulatory checklist, alerts, and meeting minutes components.",
      "status": "pending",
      "dependencies": [
        2
      ],
      "priority": "low",
      "details": "Implement the Regulatory Checklist showing compliance items with check marks. Create Alerts & Warnings for missing or expired documentation and upcoming license renewals. Build the Meeting Minutes Panel for recording audit meeting notes with auto-append to activity log. Implement Email Thread Panel to embed the last 3 client email threads via Outlook/Gmail integration.",
      "testStrategy": "Test checklist state changes. Verify alerts trigger correctly based on document status. Test meeting minutes recording and verify they appear in the activity log.",
      "subtasks": [
        {
          "id": 1,
          "title": "Implement Regulatory Checklist Component",
          "description": "Create a component that displays compliance items with check marks and status indicators",
          "status": "pending",
          "dependencies": [],
          "details": "Develop a checklist component that shows regulatory compliance items with their current status. The component should include: 1) A data model to store compliance items with attributes like item name, status (compliant/non-compliant), due date, and last check date; 2) A UI interface with checkboxes, status indicators (using color coding for quick visual reference), and the ability to filter items by category or status; 3) Functionality to mark items as complete or incomplete with timestamp tracking; 4) Integration with the backend API to fetch and update compliance data. Consider implementing a progress indicator showing overall compliance percentage. The component should follow the application's design system and be responsive for different screen sizes."
        },
        {
          "id": 2,
          "title": "Build Alerts & Warnings System",
          "description": "Develop notification components for missing documentation, expired items, and upcoming renewals",
          "status": "pending",
          "dependencies": [
            1
          ],
          "details": "Create an alerts and warnings system that monitors compliance status and notifies users of issues. Implementation should include: 1) A notification engine that checks for missing documentation, expired items, and upcoming license renewals based on predefined rules and timeframes; 2) A visual alert component with priority levels (high/medium/low) and appropriate styling for each level; 3) A dashboard widget showing a summary of current alerts with the ability to expand for details; 4) Functionality to dismiss or snooze alerts with audit logging of these actions; 5) Configuration options for alert thresholds (e.g., warn 30/60/90 days before expiration). The alerts should be persistent until resolved and should refresh automatically when underlying data changes."
        },
        {
          "id": 3,
          "title": "Develop Meeting Minutes and Email Integration Panels",
          "description": "Create components for recording audit meeting notes and displaying recent client email communications",
          "status": "pending",
          "dependencies": [
            1,
            2
          ],
          "details": "Implement two related panels for communication tracking: 1) Meeting Minutes Panel with rich text editor for recording audit meeting notes, auto-saving capability, participant tagging, action item assignment, and automatic appending to the activity log with timestamps; 2) Email Thread Panel that connects to Outlook/Gmail APIs to fetch and display the last 3 client email threads, including sender/recipient information, timestamps, subject lines, and message previews with the ability to expand full messages. Both panels should share a common design language and include search/filter capabilities. For the email integration, implement proper authentication handling, caching for performance, and privacy controls to ensure only authorized users can view email content. The panels should be collapsible and resizable to fit different workflow needs."
        }
      ]
    },
    {
      "id": 10,
      "title": "Implement Action Buttons and Client Value Projection",
      "description": "Create the action buttons and client lifetime value projection components.",
      "status": "pending",
      "dependencies": [
        3,
        7
      ],
      "priority": "low",
      "details": "Implement Action Buttons for quick actions: Add Contact, Link Bank Feed, Request Document, Schedule Audit, and Archive Client (with confirmation modal). Use the useAbility hook to gate the Archive action with the clients.archive permission. Create the Client Lifetime Value Projection chart to forecast next year's fees based on past trends.",
      "testStrategy": "Test each action button functionality. Verify Archive confirmation modal works and updates client.status correctly. Test permission gating for restricted actions. Verify projection calculations with various historical data patterns.",
      "subtasks": [
        {
          "id": 1,
          "title": "Implement Action Buttons with Permission Gating",
          "description": "Create reusable action button components for quick actions (Add Contact, Link Bank Feed, Request Document, Schedule Audit, Archive Client). Integrate the useAbility hook to gate the Archive Client button based on the clients.archive permission, and implement a confirmation modal for the Archive action.",
          "status": "pending",
          "dependencies": [],
          "details": "Define a reusable Button component, ensuring proper event handling and styling for each action. Place these buttons within the client UI, using the useAbility hook to conditionally render or disable the Archive Client button based on user permissions. For the Archive action, trigger a modal dialog to confirm the user's intent before proceeding. Reference React button best practices for accessibility and maintainability[3][5]."
        },
        {
          "id": 2,
          "title": "Integrate Action Buttons into the Client Card or Dashboard",
          "description": "Embed the action buttons into the appropriate client-facing component, such as a client card or dashboard, ensuring a cohesive and accessible layout.",
          "status": "pending",
          "dependencies": [
            1
          ],
          "details": "Update the client card or dashboard component to include the action buttons in a visually organized manner, using a container (e.g., a div with an action button group class). Ensure spacing, alignment, and responsive design. Test that each button triggers the correct handler and that the Archive button respects permission gating and confirmation modal behavior[5]."
        },
        {
          "id": 3,
          "title": "Develop Client Lifetime Value Projection Chart Component",
          "description": "Create a chart component that forecasts the client's next year's fees based on historical data and trends, and integrate it into the client view.",
          "status": "pending",
          "dependencies": [
            2
          ],
          "details": "Design and implement a chart (e.g., using a charting library like Chart.js or Recharts) that visualizes the client's historical fees and projects the next year's value using a suitable forecasting method (e.g., linear regression or moving average). Fetch and process the necessary data, and display the chart within the client dashboard or detail view, ensuring it complements the action buttons and overall UI."
        }
      ]
    },
    {
      "id": 11,
      "title": "Implement Permission Controls and RBAC",
      "description": "Apply permission gating throughout the client profile page.",
      "status": "pending",
      "dependencies": [
        3,
        5,
        6,
        7,
        8,
        9,
        10
      ],
      "priority": "high",
      "details": "Implement permission controls using useAbility() and <Authorized> components according to the useAbility rules. Gate editing features with clients.edit permission. Gate archive functionality with clients.archive permission. Restrict access to sensitive financial data (fees, estAnnFees) to Admin users only. Add RBAC tests to prevent permission drift.",
      "testStrategy": "Test with different user roles to verify appropriate access controls. Verify sensitive data is hidden from unauthorized users. Run RBAC tests to ensure permission rules are enforced consistently.",
      "subtasks": [
        {
          "id": 1,
          "title": "Integrate Permission Gating for Editing and Archiving Features",
          "description": "Apply permission controls to the client profile page to gate editing and archive functionalities using useAbility() and <Authorized> components. Ensure that only users with the appropriate permissions can access these features.",
          "status": "pending",
          "dependencies": [],
          "details": "Wrap all editing-related UI elements and actions with <Authorized> components that check for the 'clients.edit' permission using useAbility(). Similarly, gate the archive functionality with a check for the 'clients.archive' permission. Ensure that these controls are consistently applied throughout the client profile page to prevent unauthorized access to editing and archiving features."
        },
        {
          "id": 2,
          "title": "Restrict Access to Sensitive Financial Data for Admin Users",
          "description": "Implement permission checks to ensure that sensitive financial fields (fees, estAnnFees) are only visible to Admin users on the client profile page.",
          "status": "pending",
          "dependencies": [
            1
          ],
          "details": "Identify all UI components and data fetches related to sensitive financial information. Use useAbility() and <Authorized> components to conditionally render these fields only if the current user has the 'Admin' role or equivalent permission. Ensure that both frontend display and any client-side logic respect this restriction, preventing non-Admin users from accessing or inferring sensitive financial data."
        },
        {
          "id": 3,
          "title": "Add and Validate RBAC Tests to Prevent Permission Drift",
          "description": "Develop and maintain automated tests to verify that permission gating and RBAC rules are enforced correctly on the client profile page, preventing unauthorized access and permission drift.",
          "status": "pending",
          "dependencies": [
            1,
            2
          ],
          "details": "Write unit and integration tests that simulate users with different roles and permissions, verifying that editing, archiving, and sensitive financial data are only accessible to authorized users. Use testing utilities to mock useAbility() and <Authorized> behavior. Ensure tests cover edge cases, such as role changes and permission updates, to catch regressions and maintain RBAC integrity over time."
        }
      ]
    },
    {
      "id": 12,
      "title": "Optimize Performance and Finalize UI",
      "description": "Optimize data loading, implement responsive design, and conduct final testing.",
      "status": "pending",
      "dependencies": [
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11
      ],
      "priority": "medium",
      "details": "Optimize data loading with pagination, lazy-loading, and Suspense boundaries for non-critical sections. Implement responsive design adjustments for all components. Conduct accessibility (A11y) checks and fixes. Create Storybook stories and unit tests for key components. Address performance issues with data volume by using select queries and optimizing bundle size.",
      "testStrategy": "Run performance tests to measure load times and identify bottlenecks. Test responsive behavior across devices. Conduct accessibility audit. Run unit tests and Storybook visual regression tests.",
      "subtasks": [
        {
          "id": 1,
          "title": "Optimize Data Loading and Performance",
          "description": "Implement efficient data loading strategies and address performance bottlenecks related to large data volumes.",
          "status": "pending",
          "dependencies": [],
          "details": "Apply pagination and lazy-loading for long lists using techniques such as windowing (e.g., react-window or react-virtualized). Use React.lazy and Suspense boundaries to defer loading of non-critical components. Optimize bundle size with code-splitting and dynamic imports. Refactor data queries to use select queries that fetch only necessary fields. Apply memoization (useMemo, React.memo) to reduce unnecessary re-renders and computations.[1][2][5]"
        },
        {
          "id": 2,
          "title": "Implement Responsive and Accessible UI",
          "description": "Ensure all UI components are responsive across devices and meet accessibility (A11y) standards.",
          "status": "pending",
          "dependencies": [
            1
          ],
          "details": "Update CSS and layout logic to support responsive design for all components (e.g., using CSS Grid, Flexbox, and media queries). Conduct accessibility checks (using tools like axe or Lighthouse) and fix issues such as missing ARIA attributes, insufficient color contrast, and keyboard navigation. Adjust UI elements to maintain usability and accessibility on different screen sizes."
        },
        {
          "id": 3,
          "title": "Finalize UI with Storybook and Testing",
          "description": "Create Storybook stories and implement unit tests for key components, ensuring UI consistency and reliability.",
          "status": "pending",
          "dependencies": [
            2
          ],
          "details": "Develop comprehensive Storybook stories for all major UI components, covering various states and interactions. Write unit tests for critical components and logic using a testing framework (e.g., Jest, React Testing Library). Verify that all performance, responsiveness, and accessibility optimizations are preserved during testing. Address any regressions or issues identified."
        }
      ]
    }
  ],
  "metadata": {
    "projectName": "Client Profile Page Implementation",
    "totalTasks": 12,
    "sourceFile": "scripts/PRD_phase2-clientPage.txt",
    "generatedAt": "2023-11-14"
  }
}