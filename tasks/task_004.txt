# Task ID: 4
# Title: Implement Teams Chat Integration
# Status: in-progress
# Dependencies: None
# Priority: medium
# Description: Create backend and frontend components to integrate Microsoft Teams chat functionality, allowing users to view chat history and send messages within the portal.
# Details:
1. Create tRPC `chatRouter` with procedures: `listRecent`, `getMessages`, `sendMessage`, `findUsers`, `createOneToOne`, `createGroup`
2. Configure Graph API permissions: `Chat.ReadWrite`, `User.Read.All`
3. Implement `/chat` page with chat list pane, message pane, and message input components
4. Add pagination/infinite scroll for message history
5. Create user search functionality for starting new chats
6. Implement new chat creation flows (1:1 and group)
7. Add loading states and error handling

# Test Strategy:
1. Verify chat list and messages load correctly
2. Test message sending functionality
3. Confirm user search and new chat creation work as expected
4. Validate pagination/infinite scroll with large chat histories
5. Test error handling for network issues and permission problems

# Subtasks:
## 1. Set Up Microsoft Teams API Integration and Permissions [done]
### Dependencies: None
### Description: Configure Microsoft Graph API access and ensure the application has the necessary permissions to read and send Teams chat messages.
### Details:
Register the application in Azure AD, configure required API permissions (`Chat.ReadWrite`, `User.Read.All`), and set up authentication flows. Ensure admin consent is granted for these permissions so the backend can interact with Teams chat endpoints.

## 2. Implement tRPC Chat Router and Backend Procedures [done]
### Dependencies: 4.1
### Description: Develop the backend chat router with all necessary procedures for chat operations.
### Details:
Create a tRPC `chatRouter` with procedures: `listRecent`, `getMessages`, `sendMessage`, `findUsers`, `createOneToOne`, and `createGroup`. Each procedure should interact with the Microsoft Graph API to perform its respective function, handling authentication and error cases.

## 3. Develop Frontend Chat Page and Core UI Components [done]
### Dependencies: 4.2
### Description: Build the main `/chat` page with chat list, message pane, and message input, connecting to the backend procedures.
### Details:
Implement the chat list pane to display recent chats, a message pane to show chat history, and a message input component for sending messages. Connect these components to the tRPC backend and ensure real-time updates where possible.

<info added on 2025-04-23T09:07:45.221Z>
For subtask 4.3, implement the chat page with the following structure:

```tsx
// src/app/(pages)/chat/page.tsx
'use client';

import { useState } from 'react';
import { api } from '@/trpc/react';
import ChatList from '@/components/chats/ChatList';
import ChatWindow from '@/components/chats/ChatWindow';
import MessageInput from '@/components/chats/MessageInput';

export default function ChatPage() {
  const [selectedChatId, setSelectedChatId] = useState<string | null>(null);
  
  // Fetch recent chats
  const { data: chats, isLoading: chatsLoading, error: chatsError } = 
    api.chat.listRecent.useQuery();
  
  // Fetch messages for selected chat
  const { data: messages, isLoading: messagesLoading, error: messagesError } = 
    api.chat.getMessages.useQuery(
      { chatId: selectedChatId! },
      { enabled: !!selectedChatId }
    );
  
  // Send message mutation
  const sendMessageMutation = api.chat.sendMessage.useMutation({
    onSuccess: () => {
      // Invalidate queries to refresh data
      queryClient.invalidateQueries(['chat.getMessages']);
    }
  });
  
  const handleSendMessage = (content: string) => {
    if (!selectedChatId) return;
    
    sendMessageMutation.mutate({
      chatId: selectedChatId,
      content
    });
  };

  return (
    <div className="flex h-screen">
      <div className="w-1/4 border-r">
        {chatsLoading ? (
          <p>Loading chats...</p>
        ) : chatsError ? (
          <p>Error loading chats</p>
        ) : (
          <ChatList 
            chats={chats || []} 
            selectedChatId={selectedChatId}
            onSelectChat={setSelectedChatId}
          />
        )}
      </div>
      
      <div className="flex flex-col w-3/4">
        {!selectedChatId ? (
          <div className="flex-1 flex items-center justify-center">
            <p>Select a chat to start messaging</p>
          </div>
        ) : (
          <>
            <div className="flex-1 overflow-y-auto p-4">
              {messagesLoading ? (
                <p>Loading messages...</p>
              ) : messagesError ? (
                <p>Error loading messages</p>
              ) : (
                <ChatWindow messages={messages || []} />
              )}
            </div>
            <div className="p-4 border-t">
              <MessageInput 
                onSendMessage={handleSendMessage}
                isLoading={sendMessageMutation.isLoading}
              />
            </div>
          </>
        )}
      </div>
    </div>
  );
}
```

Include proper error handling, loading states, and query invalidation for real-time updates. Style with Tailwind CSS classes for responsive layout.
</info added on 2025-04-23T09:07:45.221Z>

## 4. Add Pagination, Infinite Scroll, and User Search Functionality [done]
### Dependencies: 4.3
### Description: Enhance the chat UI with message history pagination/infinite scroll and implement user search for starting new chats.
### Details:
Implement pagination or infinite scroll in the message pane to load older messages as the user scrolls. Add a user search component that leverages the `findUsers` backend procedure, enabling users to search and select contacts for new chats.

## 5. Implement New Chat Creation Flows and Robust UX States [in-progress]
### Dependencies: 4.4
### Description: Enable creation of new one-to-one and group chats, and add comprehensive loading and error handling throughout the chat experience.
### Details:
Integrate flows for creating new chats (both 1:1 and group) using the respective backend procedures. Ensure all UI components display appropriate loading indicators and error messages, providing a smooth and resilient user experience.

