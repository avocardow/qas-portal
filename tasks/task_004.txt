# Task ID: 4
# Title: Implement PermissionProvider and useAbility Hook
# Status: pending
# Dependencies: 3
# Priority: high
# Description: Create a React context provider that loads user permissions and exposes them through a custom hook.
# Details:
1. Create `src/contexts/PermissionContext.tsx`
2. Implement a provider that fetches the current user's roles on mount
3. Initialize the permission library with policies from task #3
4. Create a `useAbility` hook that returns permission checking functions
5. Add methods like `can(action, subject)` and `cannot(action, subject)`
6. Include TypeScript types for all exports
7. Add caching to prevent unnecessary re-renders
8. Implement a way to refresh permissions when roles change

# Test Strategy:
Write unit tests with React Testing Library to verify the provider initializes correctly and the hook returns expected values for different user roles. Test that permission changes are reflected correctly.

# Subtasks:
## 1. Create PermissionContext with TypeScript Types [pending]
### Dependencies: None
### Description: Set up the foundation for the permission system by creating the context structure, defining TypeScript interfaces, and establishing the permission model.
### Details:
1. Create `src/contexts/PermissionContext.tsx` file
2. Define TypeScript interfaces for permissions, roles, and context value
3. Create a basic context structure using React's createContext
4. Define types for actions (e.g., 'create', 'read', 'update', 'delete') and subjects (e.g., 'project', 'user', 'message')
5. Create a type-safe interface for the ability-checking functions (can/cannot)
6. Export the context and necessary types
7. Test the types by creating a simple mock implementation

Implement using TypeScript generics to ensure type safety across the permission system. Use discriminated union types for actions and subjects to enable autocomplete in consuming components.

## 2. Implement PermissionProvider with Role Fetching [pending]
### Dependencies: 4.1
### Description: Create the provider component that fetches user roles and initializes the permission system with policies from the previous task.
### Details:
1. Import the context created in subtask #1
2. Create a PermissionProvider component that accepts children
3. Implement a useEffect hook to fetch the current user's roles on mount
4. Add state to store the fetched roles and loading status
5. Initialize the permission library with policies from task #3
6. Create a memoized value object containing permission state and functions
7. Wrap the children with the context provider
8. Add error handling for failed role fetching
9. Implement a refreshPermissions function to reload permissions when needed

Use React.memo and useMemo to prevent unnecessary re-renders. Implement proper loading states during the initial fetch. Consider using SWR or React Query for data fetching with built-in caching and revalidation capabilities.

## 3. Develop useAbility Hook with Caching [pending]
### Dependencies: 4.1, 4.2
### Description: Create a custom hook that provides permission checking functions with performance optimizations to prevent unnecessary re-renders.
### Details:
1. Create a new file for the hook (e.g., `src/hooks/useAbility.ts`)
2. Import the PermissionContext
3. Implement the useAbility hook that consumes the context
4. Add the core permission checking methods: can(action, subject) and cannot(action, subject)
5. Implement memoization for permission check results to prevent re-renders
6. Add TypeScript generics to ensure type safety
7. Include error handling for when the hook is used outside the provider
8. Add unit tests for the hook functionality

Use React.useCallback to memoize the permission checking functions. Implement a simple caching mechanism using a Map to store previous check results. Consider adding a debug mode that logs permission checks in development environments.

## 4. Implement Permission Refresh Mechanism [pending]
### Dependencies: 4.2, 4.3
### Description: Create a system to refresh permissions when user roles change and integrate the permission system with the application.
### Details:
1. Enhance the PermissionProvider to expose a refreshPermissions method
2. Implement a permission cache invalidation mechanism
3. Create an event-based system to trigger permission refreshes (e.g., after user profile updates)
4. Add a usePermissionRefresh hook that components can use to trigger refreshes
5. Implement optimistic updates for better UX during permission changes
6. Create a higher-order component (HOC) for protecting routes based on permissions
7. Add integration tests that verify the refresh mechanism works correctly
8. Document the complete permission system with usage examples

Use React's useReducer for complex state management of the permission system. Implement a pub/sub pattern for permission change notifications across the application. Consider adding a small localStorage cache to persist permissions between page refreshes for improved performance.

