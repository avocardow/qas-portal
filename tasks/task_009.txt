# Task ID: 9
# Title: Update Table and UI Components
# Status: in-progress
# Dependencies: 4, 5
# Priority: medium
# Description: Refactor client tables and action buttons to respect the new permission system.
# Details:
1. Update `ClientsPage.tsx` to show/hide admin-only columns based on permissions
2. Wrap the "New Client" button with the `<Authorized>` component
3. Update any other action buttons with appropriate permission checks
4. Implement graceful fallback states for missing permissions
5. Ensure responsive design is maintained when elements are hidden
6. Test with different user roles to verify correct visibility

# Test Strategy:
Write component tests that verify tables and buttons are correctly shown or hidden based on user permissions. Test with all defined user roles to ensure correct behavior.

# Subtasks:
## 1. Refactor Client Table Columns for Permission-Based Visibility [done]
### Dependencies: None
### Description: Update the ClientsPage.tsx table to show or hide admin-only columns based on the current user's permissions.
### Details:
Identify which columns are admin-only. Use the new permission system to conditionally render these columns. Ensure that hiding columns does not break table layout or responsiveness. Test with different permission sets to confirm correct column visibility.

<info added on 2025-04-28T11:27:29.275Z>
## Implementation Plan

1. **Identify Admin-Only Columns**:
   - Review `ClientsPage.tsx` to identify columns that should be restricted (likely billing info, sensitive contact details, etc.)
   - Create a mapping of column keys to required permissions (e.g., `{ 'billingInfo': 'clients.view.billing' }`)

2. **Permission Integration**:
   - Import the permission hooks: `import { useAbility } from '@/hooks/useAbility';`
   - Apply conditional rendering in column definitions:
   ```tsx
   const { can } = useAbility();
   
   const columns = [
     // Always visible columns
     { key: 'name', title: 'Client Name' },
     
     // Conditionally visible columns
     ...(can('clients.view.billing') ? [
       { key: 'billingRate', title: 'Billing Rate' },
       { key: 'paymentTerms', title: 'Payment Terms' }
     ] : []),
   ];
   ```

3. **Layout Preservation**:
   - Use CSS Grid or Flexbox for the table to ensure it remains responsive
   - Add `colSpan` adjustments for any header groups when columns are hidden
   - Test with various screen sizes to verify responsive behavior

4. **Testing Strategy**:
   - Create test cases with mock users having different permission sets
   - Verify column visibility matches expected permissions
   - Test table sorting and filtering still work when columns are hidden

5. **Performance Considerations**:
   - Memoize the columns array with useMemo to prevent unnecessary re-renders
   - Ensure permission checks are optimized and not causing excessive re-renders
</info added on 2025-04-28T11:27:29.275Z>

<info added on 2025-04-28T11:30:41.954Z>
## Implementation Details

1. **Column Definition Structure**:
   - Refactor column definitions to include permission metadata:
   ```tsx
   interface ColumnDefinition {
     key: string;
     title: string;
     permission?: string; // Optional permission required to view this column
     render?: (value: any, record: any) => React.ReactNode;
   }
   ```

2. **Column Filtering Logic**:
   ```tsx
   const allColumns: ColumnDefinition[] = [
     { key: 'name', title: 'Client Name' },
     { key: 'email', title: 'Email' },
     { key: 'billingRate', title: 'Billing Rate', permission: 'clients.view.billing' },
     // Other columns...
   ];
   
   const visibleColumns = useMemo(() => 
     allColumns.filter(column => !column.permission || can(column.permission)),
     [allColumns, can]
   );
   ```

3. **Table Component Integration**:
   ```tsx
   // For react-table integration
   const tableColumns = useMemo(() => 
     visibleColumns.map(col => ({
       Header: col.title,
       accessor: col.key,
       Cell: col.render ? ({ value, row }) => col.render(value, row.original) : undefined
     })),
     [visibleColumns]
   );
   ```

4. **Responsive Design Adjustments**:
   ```css
   /* Add to your CSS */
   .client-table-container {
     overflow-x: auto; /* Ensures horizontal scrolling on small screens */
   }
   
   .client-table {
     min-width: 100%;
     table-layout: fixed;
   }
   
   /* Dynamic column widths based on visible columns */
   @media (max-width: 768px) {
     .client-table th, .client-table td {
       padding: 8px 4px;
     }
   }
   ```

5. **Permission Change Handling**:
   ```tsx
   // Add effect to handle permission changes during session
   useEffect(() => {
     // Re-initialize table when permissions change
     if (tableInstance.current) {
       tableInstance.current.resetResizing();
     }
   }, [can]);
   ```
</info added on 2025-04-28T11:30:41.954Z>

## 2. Wrap Action Buttons with Permission Checks [done]
### Dependencies: 9.1
### Description: Update all action buttons, including the 'New Client' button, to enforce permission checks using the <Authorized> component or equivalent logic.
### Details:
Locate all action buttons on ClientsPage.tsx and related components. Wrap each button with the <Authorized> component, specifying the required permission. Ensure that buttons are hidden or disabled for users lacking the necessary permissions, and that the UI remains consistent.

<info added on 2025-04-28T11:38:00.646Z>
## Implementation Plan

1. **Button Identification**:
   - Primary buttons: 'Add New Client', 'Export', 'Bulk Actions'
   - Row action buttons: 'Edit', 'Delete', 'View Details'
   - Filter/sort controls if they trigger sensitive actions

2. **Permission Structure**:
   - Define clear permission constants in a central location:
   ```typescript
   // permissions.ts
   export const PERMISSIONS = {
     CLIENTS: {
       CREATE: 'clients:create',
       READ: 'clients:read',
       UPDATE: 'clients:update',
       DELETE: 'clients:delete',
       EXPORT: 'clients:export'
     }
   };
   ```

3. **Implementation Examples**:
   ```tsx
   // For primary actions
   <Authorized permission={PERMISSIONS.CLIENTS.CREATE} fallback={null}>
     <Button onClick={handleAddClient}>Add New Client</Button>
   </Authorized>

   // For row actions with fallback UI
   <Authorized 
     permission={PERMISSIONS.CLIENTS.UPDATE} 
     fallback={<Button disabled tooltip="Insufficient permissions">Edit</Button>}>
     <Button onClick={() => handleEdit(client.id)}>Edit</Button>
   </Authorized>
   ```

4. **Testing Strategy**:
   - Create test cases with mock permission sets
   - Verify button presence/absence with different user roles
   - Test fallback UI rendering when specified
   - Ensure action handlers aren't triggered when permissions are missing

5. **Edge Cases**:
   - Handle compound actions requiring multiple permissions
   - Consider permission inheritance for nested components
   - Ensure proper loading states when permission checks are async
</info added on 2025-04-28T11:38:00.646Z>

## 3. Implement Graceful Fallback States for Restricted Actions [pending]
### Dependencies: 9.2
### Description: Provide user-friendly fallback UI for cases where users lack permissions, such as empty states, tooltips, or messages explaining restricted access.
### Details:
For each restricted action or hidden element, add fallback UI elements (e.g., tooltips, banners, or placeholder text) to inform users why features are unavailable. Ensure these states are accessible and maintain the overall responsive design.

## 4. Test and Validate Permission-Based UI with Multiple User Roles [pending]
### Dependencies: 9.3
### Description: Thoroughly test the updated table and UI components with various user roles to verify correct permission enforcement and responsive behavior.
### Details:
Create or use test accounts with different permission levels (e.g., admin, standard user, restricted user). Validate that columns and buttons appear or are hidden as expected. Check that fallback states render properly and that the UI remains responsive across devices and screen sizes.

