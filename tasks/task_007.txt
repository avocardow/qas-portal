# Task ID: 7
# Title: Create Database Migration Script
# Status: in-progress
# Dependencies: 2, 3
# Priority: medium
# Description: Develop a script to migrate existing permission constants into the Supabase permissions and rolePermissions tables.
# Details:
1. Create a Node.js script or SQL file in `scripts/migratePermissions.js` or `scripts/migratePermissions.sql`
2. Extract all unique permissions from the policy definitions
3. Insert these into the `permissions` table with appropriate descriptions
4. Map roles to permissions based on the policy file
5. Insert these mappings into the `rolePermissions` table
6. Add error handling and validation
7. Make the script idempotent (safe to run multiple times)
8. Document how to run the script via Supabase SQL editor or CLI

# Test Strategy:
Test the script in a development environment first. Verify that all permissions are correctly inserted and that role mappings match the policy definitions. Create a rollback script for safety.

# Subtasks:
## 1. Extract Unique Permissions from Policy Definitions [done]
### Dependencies: None
### Description: Parse the existing policy definitions to identify and extract all unique permission constants required for migration.
### Details:
Implement a parser (in Node.js or SQL) that scans the policy files, collects all unique permission constants, and prepares them for insertion. Ensure the extraction logic handles duplicates and edge cases.

## 2. Insert Permissions into Supabase Permissions Table [done]
### Dependencies: 7.1
### Description: Insert the extracted permissions into the Supabase `permissions` table, including appropriate descriptions for each permission.
### Details:
Develop logic to insert each unique permission into the `permissions` table. Use SQL `INSERT ... ON CONFLICT DO NOTHING` or equivalent to ensure idempotency. Provide meaningful descriptions for each permission, either from the policy file or by generating them programmatically.

## 3. Map Roles to Permissions Based on Policy File [done]
### Dependencies: 7.1, 7.2
### Description: Determine the mapping between roles and permissions as defined in the policy file, preparing data for insertion into the `rolePermissions` table.
### Details:
Parse the policy file to associate each role with its corresponding permissions. Structure this mapping data for efficient batch insertion, ensuring consistency with the permissions already inserted.

<info added on 2025-04-28T10:07:37.052Z>
The mapping implementation requires careful handling of the rbacPolicy object structure. Here's additional technical information:

1. **Data Structure Analysis**: The rbacPolicy object uses a nested structure where each role maps to an array of permission strings. These permission strings need to be matched with the actual permission IDs in the database.

2. **Batch Processing Approach**: 
   ```typescript
   // Efficient batch processing example
   const roleMappings = [];
   for (const [roleName, permissions] of Object.entries(rbacPolicy)) {
     const roleId = rolesMap.get(roleName);
     if (!roleId) {
       logger.warn(`Role ${roleName} not found in database`);
       continue;
     }
     
     for (const permissionName of permissions) {
       const permissionId = permissionsMap.get(permissionName);
       if (permissionId) {
         roleMappings.push({ roleId, permissionId });
       }
     }
   }
   
   // Then use a single batch insert
   await db.rolePermissions.createMany({
     data: roleMappings,
     skipDuplicates: true
   });
   ```

3. **Validation Strategy**: Implement pre-insertion validation to ensure all referenced permissions exist, preventing partial role configurations.

4. **Transaction Management**: Consider wrapping the entire mapping process in a database transaction to ensure atomicity.

5. **Performance Optimization**: Use Map data structures for role and permission lookups rather than repeated database queries.
</info added on 2025-04-28T10:07:37.052Z>

## 4. Insert Role-Permission Mappings into rolePermissions Table [done]
### Dependencies: 7.3
### Description: Insert the role-permission mappings into the Supabase `rolePermissions` table, ensuring the process is idempotent and includes error handling.
### Details:
Implement batch insertion logic for the `rolePermissions` table, using SQL upsert patterns or equivalent to avoid duplicates. Add error handling and validation to ensure data integrity and script robustness.

<info added on 2025-04-28T10:22:03.004Z>
# Implementation Plan Review and Enhancements

## Current Implementation Analysis
- The existing migration script handles basic upsert operations but could benefit from performance and reliability improvements.
- The sequential processing of role-permission mappings may be inefficient for large datasets.

## Recommended Enhancements
1. **Transaction Management**:
   ```typescript
   // Wrap operations in a transaction for atomicity
   const { error } = await supabase.rpc('begin_transaction');
   try {
     // Perform all upsert operations
     // ...
     await supabase.rpc('commit_transaction');
   } catch (e) {
     await supabase.rpc('rollback_transaction');
     console.error('Transaction failed:', e);
   }
   ```

2. **Batch Processing**:
   ```typescript
   // Prepare batch of role-permission mappings
   const mappingBatch = rolesToProcess.flatMap(role => 
     role.permissions.map(perm => ({
       roleId: role.id,
       permissionId: perm.id,
       createdAt: new Date().toISOString()
     }))
   );
   
   // Insert in batches of 100
   for (let i = 0; i < mappingBatch.length; i += 100) {
     const batch = mappingBatch.slice(i, i + 100);
     await supabase.from('rolePermissions').upsert(batch);
   }
   ```

3. **Enhanced Validation & Reporting**:
   - Implement pre-validation to identify all missing roles/permissions before processing
   - Generate a comprehensive report of changes made and issues encountered
   - Add checksums or version tracking to detect when re-runs are necessary

4. **Retry Logic**:
   ```typescript
   const upsertWithRetry = async (data, attempts = 3) => {
     for (let i = 0; i < attempts; i++) {
       const { error } = await supabase.from('rolePermissions').upsert(data);
       if (!error) return true;
       console.warn(`Attempt ${i+1} failed, retrying...`);
       await new Promise(r => setTimeout(r, 1000 * i));
     }
     return false;
   };
   ```

5. **Verification Step**:
   - Add a verification query after migration to ensure all expected mappings exist
   - Compare actual vs. expected counts and report discrepancies
</info added on 2025-04-28T10:22:03.004Z>

## 5. Document and Validate the Migration Script [done]
### Dependencies: 7.4
### Description: Write clear documentation on how to run the migration script using the Supabase SQL editor or CLI, and validate that the script is idempotent and robust.
### Details:
Prepare a README or inline documentation explaining script usage, prerequisites, and troubleshooting. Test the script by running it multiple times to confirm idempotency and validate that all data is correctly migrated without duplication or errors.

<info added on 2025-04-28T10:43:32.385Z>
For subtask "Document and Validate the Migration Script", here's additional implementation information:

## Documentation Approach
- Create a dedicated `MIGRATION.md` file in the project root to centralize all migration-related documentation
- Add comprehensive JSDoc comments to the `migratePermissions.ts` script including:
  - `@description` - Purpose of the script
  - `@usage` - Command examples
  - `@params` - Any CLI arguments
  - `@returns` - Expected output/results

## Validation Implementation
- Implement a `--dry-run` flag that shows what would be migrated without making changes
- Add a `--verify` mode that runs post-migration queries to confirm:
  - All source permissions were successfully mapped
  - No orphaned permission records exist
  - Role-permission relationships are correctly established
- Create test fixtures with sample data to validate against edge cases

## Idempotency Enhancements
- Implement transaction wrapping to prevent partial migrations
- Add checksums for migrated data to detect and prevent duplicate runs
- Log migration runs with timestamps in a `migration_history` table

## CLI Improvements
- Add progress indicators for long-running migrations
- Implement colored console output to distinguish between info/warning/error messages
- Support environment-specific configuration via `.env` variables

## Troubleshooting Guide
- Document common error scenarios and their solutions
- Add a "Rollback Procedure" section explaining how to revert changes if needed
- Include contact information for support
</info added on 2025-04-28T10:43:32.385Z>

