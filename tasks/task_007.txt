# Task ID: 7
# Title: Implement Developer Impersonation Feature in AppHeader
# Status: in-progress
# Dependencies: 6
# Priority: medium
# Description: Add a dropdown menu in the AppHeader component that allows developers to impersonate different user roles for testing purposes without having to log out and back in.
# Details:
Create a role impersonation dropdown in the AppHeader that is only visible to users with developer permissions. The implementation should include:

1. A dropdown component in the AppHeader that displays the current role and allows switching to other available roles
2. A session management service update to handle temporary role switching without affecting the actual user permissions in the database
3. Visual indication in the UI that shows when a user is in impersonation mode (e.g., a colored border or badge)
4. The ability to revert to the original role
5. Proper access controls to ensure only developers can access this feature
6. Session persistence so the impersonated role remains active during page navigation
7. Logging of role impersonation events for security auditing

The feature should not affect production data or allow unauthorized privilege escalation. All actions taken while impersonating should be clearly marked in logs and any generated data.

# Test Strategy:
Testing should verify both functionality and security aspects:

1. Unit tests:
   - Verify the dropdown only appears for users with developer permissions
   - Test that the role switching logic correctly updates the session
   - Ensure the UI correctly reflects the impersonated state

2. Integration tests:
   - Confirm that impersonated permissions correctly limit/grant access to features
   - Verify that navigating between pages maintains the impersonated role
   - Test that logging out clears any impersonation state

3. Security tests:
   - Verify non-developer users cannot access the impersonation feature via API or direct URL manipulation
   - Ensure impersonation events are properly logged with original and impersonated user information
   - Test that impersonated roles cannot perform actions that would permanently elevate privileges

4. User acceptance testing:
   - Have developers verify the feature works as expected across different roles
   - Confirm the visual indicators are clear and intuitive
   - Verify that reverting to original role works correctly

# Subtasks:
## 1. Create ImpersonationContext and Session Management Service [in-progress]
### Dependencies: None
### Description: Implement a React Context provider and session management service to handle role impersonation state across the application without affecting database permissions.
### Details:
1. Create an ImpersonationContext.js file with state for the current impersonated role, original role, and impersonation status.
2. Implement functions for startImpersonation(role), stopImpersonation(), and getCurrentRole().
3. Add session persistence using localStorage/sessionStorage to maintain impersonation state during page navigation.
4. Create a session management service that intercepts API requests to inject impersonation headers (e.g., 'x-impersonate-role').
5. Implement security checks to ensure only users with developer permissions can activate impersonation.
6. Add logging functionality to record impersonation events with timestamps, original role, and impersonated role for security auditing.
7. Test the context by creating a simple component that uses the impersonation hooks and verifies state changes and persistence.
8. Ensure the implementation doesn't affect actual user permissions in the database by keeping impersonation at the frontend/API request level.

<info added on 2025-04-30T02:51:04.212Z>
Here's additional implementation information for the impersonation service and context:

```typescript
// src/lib/impersonationService.ts
import { Role } from '@/types';

interface ImpersonationData {
  originalRole: Role;
  impersonatedRole: Role;
  timestamp: number;
}

export const impersonationService = {
  getImpersonationData(): ImpersonationData | null {
    if (typeof window === 'undefined') return null;
    const data = sessionStorage.getItem('impersonationData');
    return data ? JSON.parse(data) : null;
  },
  
  setImpersonation(originalRole: Role, impersonatedRole: Role): void {
    const data: ImpersonationData = {
      originalRole,
      impersonatedRole,
      timestamp: Date.now()
    };
    sessionStorage.setItem('impersonationData', JSON.stringify(data));
    // Log impersonation event
    console.info(`Impersonation started: ${originalRole} → ${impersonatedRole}`);
  },
  
  clearImpersonation(): void {
    const data = this.getImpersonationData();
    if (data) {
      console.info(`Impersonation ended: ${data.impersonatedRole} → ${data.originalRole}`);
      sessionStorage.removeItem('impersonationData');
    }
  },
  
  isImpersonating(): boolean {
    return this.getImpersonationData() !== null;
  }
};

// src/contexts/ImpersonationContext.tsx
export interface ImpersonationContextType {
  isImpersonating: boolean;
  originalRole: Role | null;
  impersonatedRole: Role | null;
  impersonate: (role: Role) => void;
  revert: () => void;
}

// Add API interceptor to inject headers
export const setupImpersonationInterceptor = (axiosInstance) => {
  axiosInstance.interceptors.request.use((config) => {
    const impersonationData = impersonationService.getImpersonationData();
    if (impersonationData) {
      config.headers = config.headers || {};
      config.headers['x-impersonate-role'] = impersonationData.impersonatedRole;
    }
    return config;
  });
};

// Add security check function
export const canImpersonate = (currentUserRole: Role): boolean => {
  // Only developers or admins can impersonate
  return ['DEVELOPER', 'ADMIN'].includes(currentUserRole);
};
```

For the context implementation, include error handling and role validation:

```typescript
// In ImpersonationContext.tsx
const impersonate = useCallback((role: Role) => {
  if (!canImpersonate(user.role)) {
    console.error('Permission denied: Current user cannot impersonate');
    return false;
  }
  
  if (role === user.role) {
    console.warn('Cannot impersonate your own role');
    return false;
  }
  
  impersonationService.setImpersonation(user.role, role);
  setImpersonatedRole(role);
  setOriginalRole(user.role);
  setIsImpersonating(true);
  return true;
}, [user]);
```

For testing, create a simple component:

```typescript
// src/components/ImpersonationTester.tsx
import { useImpersonationContext } from '@/contexts/ImpersonationContext';
import { Role } from '@/types';

export const ImpersonationTester = () => {
  const { isImpersonating, originalRole, impersonatedRole, impersonate, revert } = useImpersonationContext();
  
  return (
    <div className="p-4 border rounded">
      <h2>Impersonation Test</h2>
      <div>Status: {isImpersonating ? 'Active' : 'Inactive'}</div>
      {isImpersonating && (
        <div>
          <p>Original Role: {originalRole}</p>
          <p>Impersonated Role: {impersonatedRole}</p>
        </div>
      )}
      <div className="mt-4 space-x-2">
        <button onClick={() => impersonate('USER')}>Impersonate User</button>
        <button onClick={() => impersonate('ADMIN')}>Impersonate Admin</button>
        <button onClick={revert}>Stop Impersonation</button>
      </div>
    </div>
  );
};
```
</info added on 2025-04-30T02:51:04.212Z>

## 2. Implement Impersonation UI Components in AppHeader [done]
### Dependencies: 7.1
### Description: Add a dropdown menu in the AppHeader that allows developers to select different user roles for impersonation, with clear visual indicators for impersonation mode.
### Details:
1. Create a RoleImpersonationDropdown component that displays available roles for impersonation.
2. Use the ImpersonationContext from subtask 1 to manage role selection and display the current impersonated role.
3. Implement conditional rendering to only show the dropdown to users with developer permissions.
4. Add a visual indicator (colored border, badge, or banner) that clearly shows when a user is in impersonation mode.
5. Include the current impersonated role in the indicator.
6. Add a prominent 'Return to Original Role' button to exit impersonation mode.
7. Ensure the dropdown component is styled consistently with the existing AppHeader design.
8. Implement hover states and tooltips to explain the impersonation feature to developers.
9. Test the dropdown with different user roles to ensure it correctly displays and changes roles.
10. Verify that the visual indicators appear and disappear appropriately when entering and exiting impersonation mode.

## 3. Integrate Impersonation with Application Permissions and API Layer [done]
### Dependencies: 7.1, 7.2
### Description: Connect the impersonation feature with the application's permission system and API layer to ensure proper role simulation without affecting production data.
### Details:
1. Modify the application's permission checking system to consider the impersonated role when determining access rights.
2. Update API request interceptors to include impersonation headers when a user is in impersonation mode.
3. Implement backend middleware to process impersonation headers and temporarily adjust permissions for the request.
4. Add special flags to any data created or modified during impersonation to clearly mark it in logs and databases.
5. Ensure all actions taken while impersonating are logged with both the original and impersonated roles.
6. Implement safeguards to prevent unauthorized privilege escalation through the impersonation feature.
7. Create unit and integration tests to verify that impersonation correctly affects UI permissions (showing/hiding elements based on role).
8. Test API requests to confirm they include the correct impersonation headers.
9. Verify that reverting to the original role correctly restores all original permissions.
10. Document the impersonation feature for other developers, including security considerations and testing procedures.

